---
layout: post
title: "[操作系统]内存：基本分页存储管理"
date: 2023-02-12 16:51 +0800
author: jamie109
categories: [CS_course, OS]
tags: [CS course note, wangdao]
mermaid: true
math: true
---
## 1.基本分页存储管理的基本概念 
考虑支持多道程序的两种连续分配方式：固定分区分配，会产生大量内部碎片（分区大小固定，比如8M的分区放入5M的进程，里面有空的）。动态分区分配，会产生很多外部碎片（某个分区太小无法使用），虽然可以使用紧凑技术，但代价太高。**非连续分配：为用户进程分配的内存可以是一个分散的内存空间。**   
 ![20230212173035](https://cdn.jsdelivr.net/gh/jamie109/my-img/for-VSCode/20230212173035.png)   
 各个页面不一定连续存放，随便放。   
### 逻辑地址到物理地址的转换   
**连续存放**时，重定位寄存器存放模块存放的起始位置，每个模块之内是连续存放的，起始地址+逻辑地址=物理地址。  
* 页号 = 逻辑地址/页面长度（取除法的整数部分），由于**进程的页面与内存的页框有一一对应的关系**，所以可以根据页面找到页框，找到内存中的起始地址。    
* 页内偏移量 = 逻辑地址%页面长度（取除法的余数部分）  

![20230212173635](https://cdn.jsdelivr.net/gh/jamie109/my-img/for-VSCode/20230212173635.png)

![20230212174852](https://cdn.jsdelivr.net/gh/jamie109/my-img/for-VSCode/20230212174852.png)   
页面大小为2的整数次幂。
**如果每个页面大小为$2^{K}$B，用二进制数表示逻辑地址，则末尾K位即页内偏移量，其余部分（前多少位）就是页号。**   
* 逻辑地址的结构    
  ![20230212175256](https://cdn.jsdelivr.net/gh/jamie109/my-img/for-VSCode/20230212175256.png)

### 页表   
为了能知道进程的每个页面在内存中存放的位置，操作系统要为**每个进程建立一张页表**。进程分很多页面，内存分很多页框。   
![20230212175538](https://cdn.jsdelivr.net/gh/jamie109/my-img/for-VSCode/20230212175538.png)   
**每个页表项的长度是相同的，页号是隐含的。**   
![20230212180228](https://cdn.jsdelivr.net/gh/jamie109/my-img/for-VSCode/20230212180228.png)   
>分析：题目给了内存和页面大小，而页面跟内存要分成的页框是一样大的，所以可以计算出一共有多少个页框（内存块）。对于这些内存块，肯定得要从0开始的数一一表示，就可以确定要几个二进制位来表示内存块号，进一步确定这个内存块号需要几个字节。   
>本题中是3个字节。因为页号是0123456这样排的，没必要存它，但是内存块号肯定不是按顺序来的（非连续分配）。我要找第m页对应的内存块（其实是找到这个内存块的地址，然后找到它存的内容——**内存中该内存块的编号**），页表起始地址+3*m，就找到该页面对应的内存块号，$块号*块的大小=块的起始地址$。   
>**一开始没搞懂是我忽略了页表项中的内容是内存中某个内存块的块号，而我们要计算的是这个页表项的地址。**    

## 2.基本地址变换机构   
基本地址变换机构，在基本分页存储管理中，用于实现逻辑地址到物理地址转换的一组硬件机构。借助进程的页表，讲逻辑地址转换为物理地址。   
**页表寄存器，PTR，存放页表在内存中的起始地址F和页表长度M**。进程未执行的时候，F和M放在进程控制块PCB中，进程被调度时，操作系统内核将其放到PTR中。**PCB放在内存的系统区。**    
**程序计数器，PC，指向下一条指令的逻辑地址A。**   
流程描述： 

![20230212204954](https://cdn.jsdelivr.net/gh/jamie109/my-img/for-VSCode/20230212204954.png)   
文字描述：  
![20230212205417](https://cdn.jsdelivr.net/gh/jamie109/my-img/for-VSCode/20230212205417.png)   
>第一次访问内存：查页表。第二次，访问目标内存单元。    
>一句话概述：物理地址 = 内存块号*页面大小 + 页内偏移量，别忘了页号检查。   

![20230212205754](https://cdn.jsdelivr.net/gh/jamie109/my-img/for-VSCode/20230212205754.png)  
>页式管理中地址是一维的，可以理解为线性函数。  

对页表项目的探讨：  
![20230212210115](https://cdn.jsdelivr.net/gh/jamie109/my-img/for-VSCode/20230212210115.png)

## 3.具有**快表**的地址变换机构   

### 局部性原理   
**时间局部性**：如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行；如果某个数据被访问过，不久之后该数据很可能再次被访问。(因为程序中存在大量的循环)    
**空间局部性**：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。(因为很多数据在内存中都是连续存放的）    
在**基本地址变换机构**中，每次都要访问一个逻辑地址，都需要**查找内存中的页表**。由于局部性原理，**可能连续很多次查到的都是一个页表项**。利用局部性原理减少访问内存的次数？    
### 快表TLB   
又称联想寄存器(TLB) ，是一种访问速度比内存快很多的高速缓冲存储器，**用来存放当前访问的若干页表项，以加速地址变换的过程**。与此对应，内存中的页表常称为慢表。  
如果查询快表命中，就不需要查询页表了。快表中存放的是页表中的一部分副本。

![20230212211658](https://cdn.jsdelivr.net/gh/jamie109/my-img/for-VSCode/20230212211658.png)   

如果快表命中，访问某个逻辑地址只需一次访存，若不命中，需要两次访存（在找到页表项后应同时将其存入快表，如果快表已满，必须按照一定算法对旧的页表项进行替换）   
## 4.两级页表   
### 单级页表的问题  
1. 根据页号查找页表的方法，页表起始地址+页号*页表项长度，要在**所有的页表项都连续存放的基础上**才能使用这种方法。所有的页表项都要连续存放，页表很大时，需要占用很多个连续的页框。   
2. 根据局部性原理，**进程在一段时间可能只访问某几个特定的页面，没有必要让整个页表常驻内存**。  

相似问题：进程在内存中连续存储。解决方法，把进程地址空间分页，为其建立一张页表，记录各页面的存放位置。   
同样思路，**把必须连续存放的分页的页表再分页！**将页表分组，使每个内存块刚好可以放入一个分组，再将各组离散地放到各个内存块中。另外，要为离散分配的页表再建立一张页表，称为**页目录表**，或称外层（顶层）页表。

### 两级页表原理   
![20230212214212](https://cdn.jsdelivr.net/gh/jamie109/my-img/for-VSCode/20230212214212.png)   
**逻辑地址可以分成三部分，一级页号+二级页号+页内偏移量。**

![20230212214401](https://cdn.jsdelivr.net/gh/jamie109/my-img/for-VSCode/20230212214401.png)  
**地址转换**

![20230212214705](https://cdn.jsdelivr.net/gh/jamie109/my-img/for-VSCode/20230212214705.png)   
两级页表解决了问题一。问题二的解决思路（不用看，后面虚拟内存的时候会讲）：  
![20230212214922](https://cdn.jsdelivr.net/gh/jamie109/my-img/for-VSCode/20230212214922.png)

### 两个细节   
![20230212215254](https://cdn.jsdelivr.net/gh/jamie109/my-img/for-VSCode/20230212215254.png)  
>N级页表的访存次数是N+1次

> thanks for [B站王道计算机教育](https://www.bilibili.com/video/BV1YE411D7nH?p=8&spm_id_from=pageDriver&vd_source=38881132948112534788036151fc388f)

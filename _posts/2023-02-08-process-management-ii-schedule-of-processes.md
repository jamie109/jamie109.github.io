---
layout: post
author: jamie109
title: 'Process Management II: Schedule of Processes'
date: 2023-02-08 13:44 +0800
categories: [CS_course, OS]
tags: [CS course note, wangdao]
mermaid: true
---

> Good design demands good compromises.

## 1.线程概念、多线程模型  
### 线程  
有的进程可能需要同时做很多事情，传统的进程只能串行执行一系列程序。为此，**引入线程，来增加并发度。**传统进程机制中，进程是资源分配、调度的基本单位。引入线程后，**进程是资源分配的基本单位，线程是调度的基本单位。**  
可以把线程理解为“轻量级进程”，线程是一个基本的CPU执行单元，也是程序执行流的最小单位。**线程进一步提升了系统的并发度。**  
对**系统开销**来说，传统进程并发，需要切换进程的运行环境，系统开销大；同一个进程内的线程间并发，不需要切换进程环境，开销小。  

### 线程的属性　　
<img src="https://cdn.jsdelivr.net/gh/jamie109/my-img/for-VSCode/20230208140112.png" width="80%">  

### 线程的实现方式  
* 用户级线程,User-Level Thread,ULD  
  ![20230208140714](https://cdn.jsdelivr.net/gh/jamie109/my-img/for-VSCode/20230208140714.png)

* 内核级线程,Kernel-Level Thread,KLT 
   
   **内核级线程才是处理机分配的单位**

  ![20230208141024](https://cdn.jsdelivr.net/gh/jamie109/my-img/for-VSCode/20230208141024.png)

* ULT和KLT组合  
  ![20230208141231](https://cdn.jsdelivr.net/gh/jamie109/my-img/for-VSCode/20230208141231.png)

### 多线程模型  
在同时支持用户级线程和内核即线程的系统中，由几个ULT映射到几个KLT的问题引出了“多线程模型”问题。

* 多对一模型  
  ![20230208141632](https://cdn.jsdelivr.net/gh/jamie109/my-img/for-VSCode/20230208141632.png)

* 一对一模型  
  ![20230208141834](https://cdn.jsdelivr.net/gh/jamie109/my-img/for-VSCode/20230208141834.png)

* 多对多模型  
  ![20230208142041](https://cdn.jsdelivr.net/gh/jamie109/my-img/for-VSCode/20230208142041.png)

## 2.处理机调度的概念、层次

### 概念

有许多任务，但资源有限，无法同时处理，**需要确定某种规则来决定处理这些任务的顺序**，这就是调度研究的问题。
例：银行取钱，普通客户先到先服务，VIP客户可被优先服务，或者时间短的优先。  
在多道程序处理中，进程数量多于CPU个数，各个进程不能同时并行地处理。处理机调度，就是**从就绪队列中按照一定的算法选择一个进程并将处理机分配给它运行**，以实现进程的并发执行。

### 调度层次  
1. 高级调度（作业调度，作业调到内存的顺序）  
   ![20230208151405](https://cdn.jsdelivr.net/gh/jamie109/my-img/for-VSCode/20230208151405.png)

2. 中级调度（内存调度，挂起的进程调到内存的顺序）  
    ![20230208151824](https://cdn.jsdelivr.net/gh/jamie109/my-img/for-VSCode/20230208151824.png)

    暂时调到外存等待的进程状态称为挂起状态（suspend）。挂起态可分为**就绪挂起、阻塞挂起**两种。  
    由原来的五状态模型变为七状态模型。  
    ![20230208152320](https://cdn.jsdelivr.net/gh/jamie109/my-img/for-VSCode/20230208152320.png)
3. 低级调度（进程调度，给进程分配处理机）  
    ![20230208152546](https://cdn.jsdelivr.net/gh/jamie109/my-img/for-VSCode/20230208152546.png)

![20230208152657](https://cdn.jsdelivr.net/gh/jamie109/my-img/for-VSCode/20230208152657.png)

## 3.进程调度的时机、切换与过程、方式  
进程调度（低级调度），就是按照某种算法从就绪队列中选择一个进程为其分配处理机。

### 调度的时机  
- 什么时候需要进程调度？  
  1. 当前运行的进程**主动**放弃处理机  
   ①进程正常终止；②运行过程中发生异常终止；③进程主动请求阻塞（等待I/O）
  2. 当前运行的进程**被动**放弃处理机  
   ①时间片用完；②更紧急的事情需要处理（I/O中断）；③更高优先级的进程进入就绪队列
- 什么时候不能进行进程调度？  
  1. **处理中断的过程中**，中断处理过程很复杂，与硬件密切相关，很难做中断处理时进行进程切换。
  2. **进程在操作系统内核程序临界区中。**这里强调内核临界区。   
     临界资源：进程需要互斥访问的资源，临界区：访问临界资源的代码。  
    内核程序临界区：访问内核数据结构的代码，比如**进程的就绪队列**（就绪进程PCB组成）。进程访问就绪队列时会加锁，还没退出临界区（临界资源没解锁）的期间，是无法进行调度和切换的。内核临界区访问临界资源应该尽快完成，否则会影响内核其它管理功能。  
  3. **原子操作的过程中**  
   
### 调度方式  
有些系统中，只允许进程主动放弃处理机；还有一些系统，进程可以主动放弃，当有更紧急的任务需要处理时，也可以强行剥夺处理机（被动放弃）。因此进程的调度也可分为两种。  
- 非剥夺（非抢占）调度方式  
    **只允许进程主动放弃处理机。**实现简单，开销小，但是无法实时处理紧急任务，适合早期批处理系统。  
- 剥夺（抢占）调度方式  
  如果有**更重要更紧急的进程需要使用处理机，直接剥夺当前进程资源。**适合分时操作系统、实时操作系统。  

### 进程的切换与过程  
进程切换：一个进程让出处理机，由另一个进程占用处理机的过程  
狭义进程调度：**从就绪队列选中一个要运行的进程**  
​广义进程调度：选择进程（要进的是哪个？） + 进程切换（一个退一个进）。

* 进程切换的过程：  
    1. 保存原进程的数据  
    2. 恢复新进程的数据  
比如程序计数器，程序状态字，各种数据寄存器等现场信息，一般保存在进程控制块PCB中。**进程调度、切换是有代价的**，过于频繁的调度、切换会导致效率低下。

## 4.调度算法的评价指标

### CPU利用率　　
CPU忙碌时间占总时间的比例。  
<img src="https://cdn.jsdelivr.net/gh/jamie109/my-img/for-VSCode/20230208160136.png" width="70%">

### 系统吞吐量  
单位时间内完成作业的数量。  
<img src="https://cdn.jsdelivr.net/gh/jamie109/my-img/for-VSCode/20230208160311.png" width="70%">

### 周转时间   
* 平均周转时间   
  作业被提交给系统开始到作业完成的时间，包括高级调度（等待作业调度）、低级调度（进程在就绪队列等待进程调度）的时间、进程在CPU执行的时间、等待I/O的时间。  
  对用户，周转时间 = 作业完成时间 - 作业提交时间  
  对操作系统，更关心整体表现，平均周转时间 = 作业完成时间之和/作业数
<!-- ![20230208160459](https://cdn.jsdelivr.net/gh/jamie109/my-img/for-VSCode/20230208160459.png)   -->
* 平均带权周转时间  
  周转时间相同的情况下，作业运行时间长的，用户体验更好（浪费的时间少）  
  带权周转时间 = 作业周转时间 / 作业实际运行时间 = （作业完成时间 - 作业提交时间）/ 作业实际运行时间  
  比如：上厕所要 1 分钟等待10 分钟，11/1=11；上厕所 10 分钟等待 1分钟，11/10=1.1

    **带权周转时间一定大于 1，越小越好**


### 等待时间  
进程/作业**处于等待处理机状态时间之和**。   
对于进程：等待时间是进程建立之后，等待被服务的时间之和（等待I/O的时间不计入）   
对于作业：作业在外存后备队列等待的时间 + 建立进程之后的等待时间

### 响应时间  
用户提交请求到首次产生响应所用的时间。

## 5.调度算法：FCFS、SJF、HRRN  
* 饥饿的概念，某进程/作业长期得不到服务。

### 先来先服务（First Come First Serve）  
公平角度考虑，**作业/进程谁先到后备队列的谁先得到服务，非抢占式算法。**

对于排在长作业（或进程）后面的短作业（或进程）要等很长时间。因此，对长作业有利，对短作业不利。不会饥饿。
![20230208163333](https://cdn.jsdelivr.net/gh/jamie109/my-img/for-VSCode/20230208163333.png)

### 短作业优先（Shortest Job First，SJF）  
* 算法思想：追求最少的平均等待时间，最少平均周转时间，最少平均带权周转时间   
* 算法规则：**需要服务时间最短的作业/进程先得到服务**   
* 可以调度作业和进程（短进程优先算法SPF）   
* SJF（短作业优先）和SPF（短进程优先）**默认是非抢占式算法**。抢占式版本：最短剩余时间优先算法SRTN   
* 优点：“最短的”平均等待时间、平均周转时间（不严谨，应该是抢占式的最短，但做题时其他选项不对的时候可以认为它是对的。最好加个限制条件，任务几乎同时到达。）   
* 缺点：不公平，短作业有利，长作业不利。   
* 可能导致饥饿，如果有源源不断的短作业到来，长作业可能一直得不到服务（饿死）   

#### 非抢占式例题   
![20230208164229](https://cdn.jsdelivr.net/gh/jamie109/my-img/for-VSCode/20230208164229.png)   
#### 抢占式例题   
>一个任务可能断断续续的执行。  

![20230208164625](https://cdn.jsdelivr.net/gh/jamie109/my-img/for-VSCode/20230208164625.png)

### 高响应比优先(HRRN)   
* 算法思想：综合考虑作业/进程的等待时间和服务时间    
* 算法规则：**每次调度时选择响应比最高的作业/进程。响应比=(等待时间+要求服务时间)/要求服务时间。**    
* **非抢占式**，除非当前作业/进程主动放弃处理机，才需要调度   
* 优点：综合考虑了等待时间和运行时间   
* 不会饥饿   
  >我觉得可以这样理解，对于运行时间相同的，优先到的早的；对于一块儿到的，优先运行时间短的。  

  ![20230208165621](https://cdn.jsdelivr.net/gh/jamie109/my-img/for-VSCode/20230208165621.png)

### 对比   
![20230208165929](https://cdn.jsdelivr.net/gh/jamie109/my-img/for-VSCode/20230208165929.png)

## 6.调度算法（时间片轮转、优先级调度、多级反馈队列）

### 时间片轮转(RR)   
* 常用于分时操作系统，注重响应时间，而非周转时间   
* 算法思想：公平，响应快，轮流地为各个进程服务。每个进程在一定时间间隔内都可以得到响应。  
* 算法规则：按照各进程到达就绪队列的顺序，轮流让各个进程执行一个**时间片**(如100ms) 。若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列队尾重新排队。   
* **用于进度调度**（作业在建立进程后才能被分配处理机时间片）   
* **抢占式算法**  
* 缺点：高频率进程切换，有一定的开销，不区分任务的紧急程度   
* 由时钟中断通知CPU时间片已到，不会饥饿   
  ![20230208172507](https://cdn.jsdelivr.net/gh/jamie109/my-img/for-VSCode/20230208172507.png)

如果时间片太大，使得每个进程都可以在一个时间片内就完成，则时间片轮转调度算法退化为先来先服务调度算法，并且会增大进程响应时间。因此时间片不能太大。
另一方面，进程调度、切换是有时间代价的（保存、恢复运行环境），因此如果时间片太小，会导致进程切换过于频繁， 系统会花大量的时间来处理进程切换，从而导致实际用于进程执行的时间比例减少。可见时间片也不能太小。

### 优先级调度   
* 调度时选择优先级高的进程，可以用于作业调度和进程调度以及之后会讲的I/O调度   
* 适用于实时操作系统，可能发生饥饿   
  
#### 非抢占式例题   
![20230208173459](https://cdn.jsdelivr.net/gh/jamie109/my-img/for-VSCode/20230208173459.png)

#### 抢占式例题   
![20230208173821](https://cdn.jsdelivr.net/gh/jamie109/my-img/for-VSCode/20230208173821.png)

* 扩展内容

![20230208174224](https://cdn.jsdelivr.net/gh/jamie109/my-img/for-VSCode/20230208174224.png)

### 多级反馈队列

* 对其他算法（FCFS、SJF、时间片、优先级）的权衡折中，抢占式，可能导致饥饿。  
* 抢占式
* 对各类型都比较公平
* 会导致饥饿，有源源不断的短进程到达时
  
![20230208175030](https://cdn.jsdelivr.net/gh/jamie109/my-img/for-VSCode/20230208175030.png)

### 对比

![20230208175317](https://cdn.jsdelivr.net/gh/jamie109/my-img/for-VSCode/20230208175317.png)


> thanks for [B站王道计算机教育](https://www.bilibili.com/video/BV1YE411D7nH?p=8&spm_id_from=pageDriver&vd_source=38881132948112534788036151fc388f)

---
layout: post
title: 9-15é“¾è¡¨
date: 2023-09-15 15:39 +0800
categories: [JOB, å‰‘æŒ‡offer]
tags: [å‰‘æŒ‡offer, é“¾è¡¨]
mermaid: true
math: true
---

## 1ã€åˆå¹¶ä¸¤ä¸ªæ’åºçš„é“¾è¡¨

### [é¢˜ç›®](https://www.nowcoder.com/practice/d8b6b4358f774294a89de2a6ac4d9337?tpId=13&tqId=23267&ru=%2Fpractice%2Fbeb5aa231adc45b2a5dcc5b62c93f593&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&sourceUrl=)

### æ€è·¯

1ã€æ–°å»ºä¸€ä¸ªé“¾è¡¨ï¼ŒåŒæ—¶éå†è¿™ä¸¤ä¸ªé“¾è¡¨ï¼ŒæŠŠå°çš„åŠ åˆ°æ–°é“¾è¡¨ä¸Šï¼Œå¾ªç¯ç»“æŸä¹‹åæŠŠéç©ºçš„é“¾è¡¨æŒ‚åˆ°æ–°é“¾è¡¨æœ«å°¾ã€‚åœ¨åˆå§‹åŒ–æ–°é“¾è¡¨çš„å¤´ç»“ç‚¹çš„æ—¶å€™ï¼Œæˆ‘ä»¬å¯ä»¥è‡ªå·±ç»™å®ƒä¸€ä¸ªå€¼ï¼Œä¿è¯å¾ªç¯è¿‡ç¨‹ä¸­æ¯ä¸ªèŠ‚ç‚¹éƒ½æœ‰å‰é©±ï¼Œæœ€åè¿”å›æ–°é“¾è¡¨å¤´çš„nextã€‚ï¼ˆå¦‚æœä¸è¿™æ ·ï¼Œéœ€è¦æ‰‹åŠ¨ç»™æ–°é“¾è¡¨çš„å¤´ç»“ç‚¹èµ‹å€¼---ä¸¤ä¸ªé“¾è¡¨ä¸­æœ€å°çš„å…ƒç´ ã€‚ï¼‰

2ã€æŠŠä¸€ä¸ªé“¾è¡¨ä¸­çš„å…ƒç´ æ’åˆ°å¦ä¸€ä¸ªé“¾è¡¨ä¸­ã€‚

3ã€é€’å½’ã€‚æ¯æ¬¡å–ä¸¤ä¸ªé“¾è¡¨ä¸­å¤´ç»“ç‚¹è¾ƒå°çš„èŠ‚ç‚¹ï¼Œæ‘˜å‡ºæ¥ï¼Œå®ƒçš„åç»§æ˜¯â€œå‰©ä¸‹çš„ä¸¤ä¸ªé“¾è¡¨åˆå¹¶ä¹‹åçš„â€ã€‚


### ä»£ç 

```
1ã€å¾ªç¯
ListNode* Merge(ListNode* pHead1, ListNode* pHead2) {
        // write code here
        if (pHead1 == nullptr)
            return pHead2;
        if (pHead2 == nullptr)
            return pHead1;

        ListNode* Lmerge;
        if (pHead1->val < pHead2->val) {
            Lmerge = pHead1;
            pHead1 = pHead1->next;
        
        } else {
            Lmerge = pHead2;
            pHead2 = pHead2->next;
        }

        ListNode* rear = Lmerge;

        while (pHead1 && pHead2) {
            if (pHead1->val < pHead2->val) {
                rear->next = pHead1;
                rear = rear->next;
                pHead1 = pHead1->next;
            } else {
                rear->next = pHead2;
                rear = rear->next;
                pHead2 = pHead2->next;
            }
        }
        
        while(pHead1){
            rear->next = pHead1;
            rear = rear->next;
            pHead1 = pHead1->next;
        }
        
         while(pHead2){
            rear->next = pHead2;
            rear = rear->next;
            pHead2 = pHead2->next;
        }
        
        return Lmerge;
    }

2ã€
  ListNode* Merge(ListNode* pHead1, ListNode* pHead2) {
        // write code here
        if (pHead1 == nullptr)
            return pHead2;
        if (pHead2 == nullptr)
            return pHead1;
        if(pHead1->val > pHead2->val){
            ListNode* tmp = pHead1;
            pHead1 = pHead2;
            pHead2 = tmp;
        }       
        ListNode* Lmerge = pHead1;
        //pHead1 = pHead1->next;
        while(pHead1->next && pHead2){
            if(pHead2->val < pHead1->next->val){
                ListNode* node = pHead1->next;
                pHead1->next = pHead2;
                pHead2 = pHead2->next;
                pHead1->next->next = node;
            }
            pHead1 =pHead1->next;
        }
        if(pHead1->next == nullptr)
            pHead1->next = pHead2;
        return Lmerge;
    }

3ã€
    ListNode* hepler(ListNode* pHead1, ListNode* pHead2){
        if(pHead1 == nullptr) return pHead2;
        if(pHead2 == nullptr) return pHead1;
        if(pHead1->val < pHead2->val){
            pHead1->next = hepler(pHead1->next, pHead2);
            return pHead1;
        }
        else{
            pHead2->next = hepler(pHead1, pHead2->next);
            return pHead2;
        }
     }
    ListNode* Merge(ListNode* pHead1, ListNode* pHead2) {
        // write code here
        return hepler(pHead1, pHead2);
    }
```

## 2ã€ä¸¤ä¸ªé“¾è¡¨çš„ç¬¬ä¸€ä¸ªå…¬å…±ç»“ç‚¹

### [é¢˜ç›®](https://www.nowcoder.com/practice/6ab1d9a29e88450685099d45c9e31e46?tpId=13&tqId=23257&ru=%2Fpractice%2Fd8b6b4358f774294a89de2a6ac4d9337&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&sourceUrl=)

### æ€è·¯

- å…¬å…±èŠ‚ç‚¹ï¼Œä¸æ˜¯ç¬¬ä¸€ä¸ªå€¼ç›¸ç­‰çš„èŠ‚ç‚¹ã€‚è€Œæ˜¯ä»è¿™ä¸ªèŠ‚ç‚¹å¼€å§‹ï¼Œå®ƒä»¬åé¢çš„æ‰€æœ‰èŠ‚ç‚¹éƒ½ç›¸åŒã€‚æ˜¯**èŠ‚ç‚¹ç›¸ç­‰**ã€‚
  
1. æ™®é€šäºŒå±‚å¾ªç¯
2. åŒæŒ‡é’ˆã€‚ä¸¤ä¸ªé“¾è¡¨é•¿åº¦ä¸ä¸€å®šç›¸ç­‰ï¼Œä¸èƒ½ç›´æ¥ä½¿ç”¨åŒæŒ‡é’ˆï¼Œå¯ä»¥åœ¨é•¿é“¾è¡¨ä¸Šå…ˆç§»åŠ¨ä¸€æ®µè·ç¦»ï¼Œå†è¿›è¡Œæ¯”è¾ƒã€‚å› ä¸ºå…¬å…±éƒ¨åˆ†è‚¯å®šåœ¨é“¾è¡¨åé¢éƒ¨åˆ†ï¼Œæ‰€ä»¥ä¸éœ€è¦æ‹…å¿ƒè¿™ä¸€æ“ä½œå¯¼è‡´è·³è¿‡äº†ç¬¬ä¸€ä¸ªå…¬å…±ç»“ç‚¹ã€‚
3. å‡è®¾é“¾è¡¨1çš„é•¿åº¦ä¸ºaï¼Œé“¾è¡¨2çš„é•¿åº¦ä¸ºbï¼Œæ— è®ºaæ˜¯å¦ç­‰äºbï¼Œa+bæ’ç­‰äºb+aã€‚ç”±æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥è€ƒè™‘å°†ä¸¤ä¸ªé“¾è¡¨æ‹¼æ¥èµ·æ¥ï¼Œå†ä½¿ç”¨åŒæŒ‡é’ˆã€‚ä¸€ä¸ªæŒ‡é’ˆæ˜¯head1+head2ï¼Œä¸€ä¸ªæ˜¯head2+head1ã€‚éœ€è¦æ³¨æ„æ¢é“¾è¡¨çš„æ¡ä»¶æ˜¯å½“å‰æŒ‡é’ˆä¸ºnullï¼ˆå¯èƒ½æ˜¯æœ€åä¸€ä¸ªèŠ‚ç‚¹æ˜¯å…¬å…±èŠ‚ç‚¹ï¼‰ã€‚
   
### ä»£ç 

```
1ã€æ™®é€š
ListNode* FindFirstCommonNode( ListNode* pHead1, ListNode* pHead2) {
        if(pHead1== nullptr || pHead2==nullptr)
            return nullptr;
        ListNode* tmp = pHead2;

        while(pHead1){
            pHead2 = tmp;
            //cout<<pHead1->val<<endl;
            while(pHead2){
                //cout<<pHead2->val<<" ";
                if(pHead1 == pHead2)
                    return pHead1;
                pHead2 = pHead2->next;
            }
            //cout<<endl;
            pHead1 = pHead1->next;
        }
        return nullptr;  
    }
2ã€è°ƒæ•´é•¿åº¦
ListNode* FindFirstCommonNode( ListNode* pHead1, ListNode* pHead2) {
        if(pHead1== nullptr || pHead2==nullptr)
            return nullptr;
			int len1 = 0, len2 = 0;
			ListNode *p1 = pHead1, *p2=pHead2;
			while(p1){
				len1++;
				p1 = p1->next;
			}
			while(p2){
				len2++;
				p2 = p2->next;
			}
			p1 = pHead1;
			p2 = pHead2;
			if(len1 != len2){
				while(len1 > len2){
					cout<<"ok"<<endl;
					p1 = p1->next;
					len1--;
				}
				while(len1 < len2){
					cout<<"ok"<<endl;
					p2 = p2->next;
					len2--;
				}
			}
			cout<<len1<<" "<<len2<<endl;
			
			while(p1 != p2){
				cout<<p1->val<<" "<<p2->val<<endl;
				p1 = p1->next;
				p2 = p2->next;
			}
			if(p1) return p1;
			else return nullptr;
	}

3ã€
    ListNode* FindFirstCommonNode( ListNode* pHead1, ListNode* pHead2) {
        ListNode* p1 = pHead1, *p2 = pHead2;
		while(p1 != p2){
			if(p1)  p1 = p1->next;
			else    p1 = pHead2;
			if(p2)  p2 = p2->next;
			else    p2 = pHead1;
		}
		return p1;
	}
```

## 3ã€é“¾è¡¨ä¸­ç¯çš„å…¥å£èŠ‚ç‚¹

### [é¢˜ç›®](https://www.nowcoder.com/practice/253d2c59ec3e4bc68da16833f79a38e4?tpId=13&tqId=23449&ru=%2Fpractice%2F6ab1d9a29e88450685099d45c9e31e46&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&sourceUrl=)

### æ€è·¯

1. å¿«æ…¢æŒ‡é’ˆ

ä¸¤ä¸ªæŒ‡é’ˆä¸€ä¸ªfastã€ä¸€ä¸ªslowåŒæ—¶ä»ä¸€ä¸ªé“¾è¡¨çš„å¤´éƒ¨å‡ºå‘ã€‚fastä¸€æ¬¡èµ°2æ­¥ï¼Œslowä¸€æ¬¡èµ°ä¸€æ­¥ï¼Œå¦‚æœæœ‰ç¯å®ƒä»¬ä¸€å®šåœ¨ç¯å†…ç›¸é‡ã€‚
ç„¶åæŠŠå…¶ä¸­çš„ä¸€ä¸ªæŒ‡é’ˆé‡æ–°æŒ‡å‘é“¾è¡¨å¤´éƒ¨ï¼Œå¦ä¸€ä¸ªä¸å˜ï¼Œæ¯æ¬¡éƒ½åªèµ°ä¸€æ­¥ï¼Œç›¸é‡çš„åœ°æ–¹å°±æ˜¯å…¥å£èŠ‚ç‚¹ã€‚ 

2ã€ä½¿ç”¨setæˆ–è€…mapæ¥å­˜å‚¨å·²ç»éå†è¿‡çš„ç»“ç‚¹ï¼Œå½“ç¬¬ä¸€æ¬¡å‡ºç°é‡å¤çš„ç»“ç‚¹æ—¶ï¼Œå³ä¸ºå…¥å£ç»“ç‚¹ã€‚

### ä»£ç 
```
ListNode* EntryNodeOfLoop(ListNode* pHead) {
        ListNode* fast = pHead, *slow = pHead;
        bool flag = false;
        while(fast && fast->next){
            fast = fast->next->next;
            slow = slow->next;
            if(fast == slow){
                flag = true;
                break;
            }
        }
        if(flag == false)
            return nullptr;
        fast = pHead;
        while(fast != slow){
            fast = fast->next;
            slow = slow->next;
        }
        return fast;
    }

    ListNode* EntryNodeOfLoop(ListNode* pHead) {
        unordered_set<ListNode*> uset;
        while(pHead){
            if(uset.count(pHead) == 1)
                return pHead;
            uset.emplace(pHead);
            pHead = pHead->next;
        }
        return nullptr;
    }
```

## 4ã€é“¾è¡¨ä¸­å€’æ•°æœ€åkä¸ªç»“ç‚¹

### [é¢˜ç›®](https://www.nowcoder.com/practice/886370fe658f41b498d40fb34ae76ff9?tpId=13&tqId=1377477&ru=%2Fpractice%2F253d2c59ec3e4bc68da16833f79a38e4&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&sourceUrl=)

### æ€è·¯

1. å¿«æ…¢æŒ‡é’ˆã€‚ä¸€ä¸ªæŒ‡é’ˆå…ˆèµ°kæ­¥ï¼Œç¬¬äºŒä¸ªæŒ‡é’ˆåœ¨å¤´éƒ¨ï¼Œå½“ç¬¬ä¸€ä¸ªæŒ‡é’ˆåˆ°è¾¾nullæ˜¯ï¼Œç¬¬äºŒä¸ªæŒ‡é’ˆåˆ°å€’æ•°ç¬¬kä¸ªä½ç½®ã€‚
2. å…ˆè®¡ç®—é“¾è¡¨é•¿åº¦ï¼Œç„¶åæ‰¾åˆ°å€’æ•°ç¬¬kä¸ªèŠ‚ç‚¹çš„æ­£å‘ä½ç½®ã€‚

## 5ã€å¤æ‚é“¾è¡¨çš„å¤åˆ¶

### [é¢˜ç›®](https://www.nowcoder.com/practice/f836b2c43afc4b35ad6adc41ec941dba?tpId=13&tqId=23254&ru=%2Fpractice%2F886370fe658f41b498d40fb34ae76ff9&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&sourceUrl=)


### æ€è·¯

1ã€å“ˆå¸Œè¡¨ã€‚éå†ä¸€æ¬¡åŸé“¾è¡¨ï¼Œå…ˆå°†é™¤éšæœºæŒ‡é’ˆå¤–çš„éƒ¨åˆ†åˆ›å»ºå¹¶è¿æ¥ï¼ŒåŒæ—¶ç”¨å“ˆå¸Œè¡¨è®°å½•æŒ‡é’ˆä¹‹é—´çš„æ˜ å°„ï¼Œæœ€åéå†ä¸€æ¬¡å“ˆå¸Œè¡¨ï¼Œå°†éšæœºæŒ‡é’ˆæŒ‡å‘å¯¹åº”çš„ä½ç½®ã€‚

### ä»£ç 

```
1ã€ç®€å•ç²—æš´ç‰ˆæœ¬ï¼ˆæ€»ä¹‹å°±æ˜¯åšå‡ºæ¥äº†ï¼Œé¼“æŒğŸ‘ï¼‰.
ç”¨ä¸€ä¸ªvectorå­˜å‚¨é“¾è¡¨æ¯ä¸ªèŠ‚ç‚¹çš„randomæ‰€åœ¨ä½ç½®ï¼Œç”¨ä¸€ä¸ªvectorå­˜å‚¨æ–°é“¾è¡¨æ¯ä¸ªèŠ‚ç‚¹ã€‚
RandomListNode* Clone(RandomListNode* pHead) {
        int len = 0;
        RandomListNode* preHead = new RandomListNode(-1);
        RandomListNode* p = pHead,*p2 = preHead;
        vector<int> indexRandom;
        vector<RandomListNode*> vecNew;
        while(p){
            RandomListNode* cur = new RandomListNode(p->label);
            preHead->next = cur;
            preHead = cur;
            RandomListNode* tmp = pHead;
            int k = 0;
            if(p->random == nullptr) 
                indexRandom.push_back(-1);
            while(tmp){
                if(tmp == p->random){
                    indexRandom.push_back(k);
                    //cout<<k<<" ";
                    k = 0;
                }
                tmp = tmp->next;
                k++;
            }
            //cout<<vec.size()<<" ";
            vecNew.push_back(cur);
            len++;
            p = p->next;
        }
        p = pHead;
        RandomListNode* newHead = p2->next;
        cout<<endl;
        for(int i = 0; i<len;i++){
            if(indexRandom[i] != -1)
                newHead->random = vecNew[indexRandom[i]];
            //cout<<indexRandom[i]<<" ";
            newHead = newHead->next;
        }
        return p2->next;
    }

2ã€å“ˆå¸Œè¡¨
    RandomListNode* Clone(RandomListNode* pHead) {
       if(pHead == nullptr) return nullptr;
       unordered_map<RandomListNode*,RandomListNode*> mp;
       RandomListNode* preHead = new RandomListNode(-1);
       RandomListNode* p = pHead,*p2 = preHead;
       while(p){
        RandomListNode* cur = new RandomListNode(p->label);
        p2->next = cur;
        p2 = cur;
        mp[p] = cur;
        p = p->next;
       }

        for(auto& [key, value] : mp){
            value->random = key->random == nullptr?nullptr:mp[key->random];
        }
       
       delete preHead;
       return mp[pHead];
    }
```

## 6ã€åˆ é™¤é‡å¤çš„èŠ‚ç‚¹

### [é¢˜ç›®](https://www.nowcoder.com/practice/fc533c45b73a41b0b44ccba763f866ef?tpId=13&tqId=23450&ru=%2Fpractice%2Ff836b2c43afc4b35ad6adc41ec941dba&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&sourceUrl=)

### æ€è·¯

- å“ˆå¸Œè¡¨ã€‚
  éå†ä¸€æ¬¡é“¾è¡¨ç”¨å“ˆå¸Œè¡¨è®°å½•æ¯ä¸ªèŠ‚ç‚¹å€¼å‡ºç°çš„æ¬¡æ•°ï¼Œåœ¨é“¾è¡¨å‰åŠ ä¸€ä¸ªèŠ‚ç‚¹å€¼ä¸º0çš„è¡¨å¤´ï¼ˆæ–¹ä¾¿åˆ é™¤è¡¨å¤´å…ƒç´ çš„æƒ…å†µï¼‰ï¼›å†æ¬¡éå†è¯¥é“¾è¡¨ï¼Œå¯¹äºæ¯ä¸ªèŠ‚ç‚¹å€¼æ£€æŸ¥å“ˆå¸Œè¡¨ä¸­çš„è®¡æ•°ï¼Œåªç•™ä¸‹è®¡æ•°ä¸º1çš„ï¼Œå…¶ä»–æƒ…å†µéƒ½åˆ é™¤ï¼Œæœ€åè¿”å›å»æ‰å¢åŠ çš„è¡¨å¤´ã€‚

- å¦‚æœåé¢è¿˜ç”¨åˆ°äº†newå‡ºæ¥çš„å˜é‡ï¼Œåœ¨è¿™ä¹‹å‰ä¸èƒ½åˆ é™¤ã€‚

### ä»£ç 

```
    ListNode* deleteDuplication(ListNode* pHead) {
        if(pHead==nullptr || pHead->next == nullptr)
            return pHead;
        unordered_map<int,int> mp;
        ListNode* p = pHead;
        while(p){
            mp[p->val]++;
            p = p->next;
        }
        ListNode* preHead = new ListNode(-1);
        preHead->next = pHead;
        p = preHead;
        while(preHead->next){
            if(mp[preHead->next->val] != 1)
                preHead->next = preHead->next->next;
            else
                preHead = preHead->next;
        }
        return p->next;
    }
```

## 7ã€åˆ é™¤é“¾è¡¨çš„èŠ‚ç‚¹

### [é¢˜ç›®](https://www.nowcoder.com/practice/f9f78ca89ad643c99701a7142bd59f5d?tpId=13&tqId=2273171&ru=%2Fpractice%2Ffc533c45b73a41b0b44ccba763f866ef&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&sourceUrl=)

### æ€è·¯

- éœ€è¦æ³¨æ„å¤´ç»“ç‚¹æ˜¯å¾…åˆ é™¤èŠ‚ç‚¹çš„æƒ…å†µã€‚å¯ä»¥é€šè¿‡å¤šåŠ ä¸€ä¸ªå¤´ç»“ç‚¹ï¼Œä¹Ÿå¯ä»¥å•ç‹¬å¤„ç†ã€‚
- åˆ é™¤ä¸€ä¸ªèŠ‚ç‚¹ï¼Œéœ€è¦å°†å®ƒçš„å‰ä¸€ä¸ªèŠ‚ç‚¹æŒ‡å‘å®ƒçš„åä¸€ä¸ªèŠ‚ç‚¹ã€‚

### ä»£ç 

```
    ListNode* deleteNode(ListNode* head, int val) {
        // write code here
        if(head == nullptr) return head;
        if(head->val == val) return head->next;
        ListNode* p = head;
        while(head){
            if(head->next->val == val){
                head->next = head->next->next;
                return p;
            }
            head = head->next;
        }
        return nullptr;
    }
```
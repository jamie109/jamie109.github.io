---
layout: post
title: 前置++与后置++
date: 2023-10-11 16:23 +0800
categories: [JOB, C++]
tags: [C++]
mermaid: true
math: true
---

对于迭代器和其他模板对象使用**前缀**形式的自增、自减运算符。

原因：由于后置++会生成**临时对象**，会造成一次构造函数和一次析构函数的额外开销，所以前置自增 (++i) 通常要比后置自增 (i++) 效率更高。

## 1、计算结果

 - `++a`表示取a的地址，增加它的内容，然后把值放在寄存器中；

- `a++`表示取a的地址，把它的值装入寄存器，然后增加内存中的a的值。


最明显区别： `++a`是先将变量的值加1，然后使用加1后的值参与运算；`a++`是先使用该值参与运算，然后再将该值加1。

## 2、重载运算符

```
class Age   {   
public:   
	Age& operator++(){ //前置++   	       
	    ++i;   
	    return *this;   
	}  

	const Age operator++(int){  //后置++    
	    Age tmp = *this;   
	    ++(*this);  //利用前置++   
	    return tmp;   
	}        
private:   
	int i;   
};  
```

### 返回类型不同

- 前置++返回的总是被自增的对象本身，返回类型是Age&，**左值**；
- 后置++的返回类型const Age，**右值**。
- `a++`的类型是const Age，右值，不能对它进行前置++、后置++、赋值等操作。避免程序员使⽤i++++，连续两次调⽤后置++重载符，而调用两次后置++，结果只累加了⼀次，与程序员设想的不同，可能会造成错误，于是就让a++返回一个右值，无法继续运算。


### 参数类型不同

为了绕过重载的语法限制，给后置++增加了一个int形参，没什么意义。

### 代码实现不同

1. 前置++ 
   
   自增之后，将`*this`返回。

2. 后置++ 
   
   因为要返回自增之前的对象，所以先将对象拷贝一份，再进行自增（后置++利用了前置++来实现自增，可以避免**自增代码重复**），最后返回那个拷贝。


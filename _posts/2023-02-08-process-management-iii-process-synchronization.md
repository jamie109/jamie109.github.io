---
layout: post
author: jamie109
title: 'Process Management III: Process Synchronization'
date: 2023-02-08 20:33 +0800
categories: [CS_course, OS]
tags: [CS course note, wangdao]
mermaid: true
---

## 1.进程同步、互斥  
### 进程同步   
进程具有**异步性**，各并发执行的进程以各自独立、不可预测的速度向前推进。   
有时**需要保证不同的进程按照特地的次序推进**，比如管道读、写数据两个操作必需按照“写数据->读数据”的顺序执行。进程同步又叫进程的“直接制约关系”，它是指为了完成某种任务而建立两个或多个进程，这些进程因为需要在某些位置上协调工作次序而产生制约关系。
> 大概就是一个进程必须在前，一个必须在后。

### 进程互斥  
临界资源：一个时间段内只允许一个进程使用的资源（比如一些物理设备，变量数据，内存缓冲区）
对临界资源的访问必需互斥地进行，互斥又叫“间接制约关系”。**进程互斥指一个进程访问某些临界资源时，另一个想要访问该临界资源的进程必需等待，直到资源被释放。**  
>一个进程用着临界资源的那段时间，另一个不能用。  

对于临界资源的互斥访问，在逻辑上分成以下四个部分：
```C
do {
    // 进入区,负责检查是否可以进入临界区的代码，若可以进入，
    // 则设置“正在访问临界资源的标志”（上锁），阻止其它进程同时进入临界区
    entry section;      
    // 临界区,又叫临界段，是负责访问临界资源的代码
    critical section;   
    // 退出区,负责解除“正在访问临界资源的标志”（解锁）的代码
    exit section;      
    // 剩余区,其它代码
    remainder section;  
} while(true)
```
* 临界区才是进程中**访问临界资源**的代码段。 

* 进入区和退出区是负责实现互斥的代码段。
  
* 为了实现对临界资源的互斥访问，同时保证系统整体性能，需要遵循以下原则：   
  * 空闲让进，临界区空闲，应允许一个进程访问。   
  * 忙则等待，临界区正在被访问时，其它试图访问的进程需要等待。   
  * 有限等待，对于请求访问的进程，应保证能在有限的时间内进入临界区，保证不会饥饿。   
  * 让权等待，进不了临界区的进程，释放处理机，防止忙等（忙等就是指它进不来临界区，但还占着CPU）。  
  
## 2.进程互斥的软件实现方法  
### 单标志法   
* 算法思想：两个进程在**访问完临界区后**会把临界区的权限转交给另一个进程。也就是说**每个进程进入临界区的权限只能被另一个进程赋予**。
```C++
int turn = 0; // turn 表示当前允许进入临界区的进程号
```
![20230208210525](https://cdn.jsdelivr.net/gh/jamie109/my-img/for-VSCode/20230208210525.png)

1. turn的初始值为0，刚开始只允许P0进入临界区。   
2. 若P1先上处理机运行，则会一直卡在⑤（while死循环）。直到p1的时间片用完，发生调度，切换p0上处理机运行。   
3. ①不会卡住p0，p0正常访问临界区，即使在p0访问临界区时发生调度切换回p1，p1依然会卡在⑤，只有p1在退出区将turn改为1后，p1才能进入临界区。   
因此，该代码可以实现“同一时刻只允许一个进程访问临界区。”  
![20230208211713](https://cdn.jsdelivr.net/gh/jamie109/my-img/for-VSCode/20230208211713.png)
> 跟代码没啥关系，别看代码。   
> 情景：现在turn是0，只允许p0访问临界区，但p0由于某种原因（比如p0压根用不着临界资源）一直不去访问临界区，那么就无法把turn的值修改为1。此时p0不需要访问临界资源但你非要人家访问，p0偏偏不去，导致p1也访问不了，后果就是临界区空闲，p1想访问吧但进不了/(ㄒoㄒ)/~~

### 双标志先检查   
* 算法思想：设置一个布尔型数组flag[]，数组中各元素用来标记各进程想要进入临界区的意思，比如“flag[0] = ture”意味着0号进程P0想要进入临界区。每个进程进入临界区之前先检查当前有没有别的想要进入临界区的进程，如果没有则把自身对应的标志falg[i]设为true，之后开始访问临界区。   
![20230208214621](https://cdn.jsdelivr.net/gh/jamie109/my-img/for-VSCode/20230208214621.png)   
**进入区的“检查”和“上锁”两个处理不是一气呵成的。**

### 双标志后检查   
* 算法思想：双标志先检查法的改进版。因为双标志先检查法存在的问题是“检查”和“上锁”不是一气呵成的，因此导致了同时进入临界区的问题。为了避免上述问题，人们想到了**先“上锁”后“检查”**的方法。   
> 先占个位置，再检查有没有其他进程想进。

![20230208214842](https://cdn.jsdelivr.net/gh/jamie109/my-img/for-VSCode/20230208214842.png)
>以上几个算法的问题基本都跟多个进程的并发有关。   

### Peterson 算法   
单标志法存在的问题是，当前进程没有使用临界资源的意愿，但是却得到了使用临界资源的权利，从而导致另一个想要使用临界资源的进程没办法访问正在空闲着的临界资源。而双标志后检查法中当两个进程都表达了想要使用临界资源的意愿后，由于双方都不想放弃使用的意愿，从而都没办法使用临界资源。

* 算法思想：Peterson算法结合这两种算法，只有当进程有想要使用临界资源的意愿时，才允许该进程进入临界区（解决单标志法的不足）；两个进程在使用临界资源之前先表达“谦让”，最后一个表达“谦让”进程放弃使用的权利（解决双标志后检查法的不足）。

![20230208215714](https://cdn.jsdelivr.net/gh/jamie109/my-img/for-VSCode/20230208215714.png)  

>——我想要！ ——你如果也想要，我可以让给你。 ——你还要吗？不要我就用啦。  
>Peterson算法用软件方法解决了进程互斥问题，遵循了空闲让进、忙则等待、有限等待三个原则，但是依然未遵循让权等待的原则。

### 总结   
![20230208220520](https://cdn.jsdelivr.net/gh/jamie109/my-img/for-VSCode/20230208220520.png)

> 我恨！为什么上课不好好听，临近考试抱佛脚。
> 2023.02.08 [22：13：21] 为我今天的OS进程上锁！！！

## 3.进程互斥的硬件实现方法   

## 4.信号量机制

## 5.用信号量实现进程互斥、同步、前驱关系

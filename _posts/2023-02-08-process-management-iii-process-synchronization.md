---
layout: post
author: jamie109
title: 'Process Management III: Process Synchronization'
date: 2023-02-08 20:33 +0800
categories: [CS_course, OS]
tags: [CS course note, wangdao]
mermaid: true
---

## 1.进程同步、互斥  
### 进程同步   
进程具有**异步性**，各并发执行的进程以各自独立、不可预测的速度向前推进。   
有时**需要保证不同的进程按照特地的次序推进**，比如管道读、写数据两个操作必需按照“写数据->读数据”的顺序执行。进程同步又叫进程的“直接制约关系”，它是指为了完成某种任务而建立两个或多个进程，这些进程因为需要在某些位置上协调工作次序而产生制约关系。
> 大概就是一个进程必须在前，一个必须在后。

### 进程互斥  
临界资源：一个时间段内只允许一个进程使用的资源（比如一些物理设备，变量数据，内存缓冲区）
对临界资源的访问必需互斥地进行，互斥又叫“间接制约关系”。**进程互斥指一个进程访问某些临界资源时，另一个想要访问该临界资源的进程必需等待，直到资源被释放。**  
>一个进程用着临界资源的那段时间，另一个不能用。  

对于临界资源的互斥访问，在逻辑上分成以下四个部分：
```C
do {
    // 进入区,负责检查是否可以进入临界区的代码，若可以进入，
    // 则设置“正在访问临界资源的标志”（上锁），阻止其它进程同时进入临界区
    entry section;      
    // 临界区,又叫临界段，是负责访问临界资源的代码
    critical section;   
    // 退出区,负责解除“正在访问临界资源的标志”（解锁）的代码
    exit section;      
    // 剩余区,其它代码
    remainder section;  
} while(true)
```
* 临界区才是进程中**访问临界资源**的代码段。 

* 进入区和退出区是负责实现互斥的代码段。
  
* 为了实现对临界资源的互斥访问，同时保证系统整体性能，需要遵循以下原则：   
  * 空闲让进，临界区空闲，应允许一个进程访问。   
  * 忙则等待，临界区正在被访问时，其它试图访问的进程需要等待。   
  * 有限等待，对于请求访问的进程，应保证能在有限的时间内进入临界区，保证不会饥饿。   
  * 让权等待，进不了临界区的进程，释放处理机，防止忙等（忙等就是指它进不来临界区，但还占着CPU）。  
  
## 2.进程互斥的软件实现方法  
### 单标志法   
* 算法思想：两个进程在**访问完临界区后**会把临界区的权限转交给另一个进程。也就是说**每个进程进入临界区的权限只能被另一个进程赋予**。
```C++
int turn = 0; // turn 表示当前允许进入临界区的进程号
```
![20230208210525](https://cdn.jsdelivr.net/gh/jamie109/my-img/for-VSCode/20230208210525.png)

1. turn的初始值为0，刚开始只允许P0进入临界区。   
2. 若P1先上处理机运行，则会一直卡在⑤（while死循环）。直到p1的时间片用完，发生调度，切换p0上处理机运行。   
3. ①不会卡住p0，p0正常访问临界区，即使在p0访问临界区时发生调度切换回p1，p1依然会卡在⑤，只有p1在退出区将turn改为1后，p1才能进入临界区。   
因此，该代码可以实现“同一时刻只允许一个进程访问临界区。”  
![20230208211713](https://cdn.jsdelivr.net/gh/jamie109/my-img/for-VSCode/20230208211713.png)
> 跟代码没啥关系，别看代码。   
> 情景：现在turn是0，只允许p0访问临界区，但p0由于某种原因（比如p0压根用不着临界资源）一直不去访问临界区，那么就无法把turn的值修改为1。此时p0不需要访问临界资源但你非要人家访问，p0偏偏不去，导致p1也访问不了，后果就是临界区空闲，p1想访问吧但进不了/(ㄒoㄒ)/~~

### 双标志先检查   
* 算法思想：设置一个布尔型数组flag[]，数组中各元素用来标记各进程想要进入临界区的意思，比如“flag[0] = ture”意味着0号进程P0想要进入临界区。每个进程进入临界区之前先检查当前有没有别的想要进入临界区的进程，如果没有则把自身对应的标志falg[i]设为true，之后开始访问临界区。   
![20230208214621](https://cdn.jsdelivr.net/gh/jamie109/my-img/for-VSCode/20230208214621.png)   
**进入区的“检查”和“上锁”两个处理不是一气呵成的。**

### 双标志后检查   
* 算法思想：双标志先检查法的改进版。因为双标志先检查法存在的问题是“检查”和“上锁”不是一气呵成的，因此导致了同时进入临界区的问题。为了避免上述问题，人们想到了**先“上锁”后“检查”**的方法。   
> 先占个位置，再检查有没有其他进程想进。

![20230208214842](https://cdn.jsdelivr.net/gh/jamie109/my-img/for-VSCode/20230208214842.png)
>以上几个算法的问题基本都跟多个进程的并发有关。   

### Peterson 算法   
单标志法存在的问题是，当前进程没有使用临界资源的意愿，但是却得到了使用临界资源的权利，从而导致另一个想要使用临界资源的进程没办法访问正在空闲着的临界资源。而双标志后检查法中当两个进程都表达了想要使用临界资源的意愿后，由于双方都不想放弃使用的意愿，从而都没办法使用临界资源。

* 算法思想：Peterson算法结合这两种算法，只有当进程有想要使用临界资源的意愿时，才允许该进程进入临界区（解决单标志法的不足）；两个进程在使用临界资源之前先表达“谦让”，最后一个表达“谦让”进程放弃使用的权利（解决双标志后检查法的不足）。

![20230208215714](https://cdn.jsdelivr.net/gh/jamie109/my-img/for-VSCode/20230208215714.png)  

>——我想要！ ——你如果也想要，我可以让给你。 ——你还要吗？不要我就用啦。  
>Peterson算法用软件方法解决了进程互斥问题，遵循了空闲让进、忙则等待、有限等待三个原则，但是依然未遵循让权等待的原则。

### 总结   
![20230208220520](https://cdn.jsdelivr.net/gh/jamie109/my-img/for-VSCode/20230208220520.png)

> 我恨！为什么上课不好好听，临近考试抱佛脚。
> 2023.02.08 [22：13：21] 为我今天的OS进程上锁！！！

## 3.进程互斥的硬件实现方法   
> 0209 解锁

### 中断屏蔽法   
利用“开/关中断指令” 实现。与原语的实现思想相同，即在某进程开始访问临界区到结束访问为止都不允许被中断，也就不能发生进程切换，因此也不可能发生两个同时访问临界区的情况。   
```
...
关中断; //关中断后，不允许当前进程被中断，也必然不会发生进程切换
临界区;
开中断;//直到当前进程访问完临界区，再执行开中断指令，才有可能有别的进程上处理机并访问临界区
...
```

* 优点：简单、高效

* 缺点：不适用于多处理机；只适用于操作系统内核进程，不适用于用户进程（因为开/关中断指令只能运行在内核态，这组指令如果能让用户随意使用会很危险）     
  > 有AB两个处理机，A中一个进程访问临界区a，A的关中断了，但B的进程还可以访问临界区a

### TestAndSet 指令   
![20230209101813](https://cdn.jsdelivr.net/gh/jamie109/my-img/for-VSCode/20230209101813.png)    
* 检查和上锁是一起进行的    
* 不满足“让权等待”
  
> 如果临界区加锁了，lock为true，返回值为true接着作为参数传入while循环，就一直循环下去了。
> 如果临界区没有加锁，lock为false，返回值为false，跳出while循环。

### Swap 指令   
![20230209102550](https://cdn.jsdelivr.net/gh/jamie109/my-img/for-VSCode/20230209102550.png)   
> 逻辑上TestAndSet 指令和Swap 指令是一样的

## 4.信号量机制    
### 什么是信号量？

用户进程可以通过使用操作系统提供的一对**原语来**对信号量进行操作，从而很方便的实现了进程互斥、进程同步。   
**信号量其实就是一个变量(可以是一个整数，也可以是更复杂的记录型变量)**，可以用一个信号量来表示系统中某种资源的数量。比如:系统中只有一台打印机，就可以设置一个初值为1的信号量。    
​原语是一种特殊的程序段，其执行只能一气呵成，不可被中断。**原语是由关中断/开中断指令实现的。**

​软件解决方案的主要问题是由“进入区的各种操作无法一气呵成” ，因此如果能把进入区、退出区的操作都用“原语”实现,使这些操作能“一气呵成”就能避免问题。   
**一对原语：wait(S)原语和signal(S)原语**，可以理解为函数，函数名分别为wait和signal，括号里的信号量S就是参数。wait、signal原语常简称为P、V操作。因此，做题的时候常把wait(S)、signal(S)两个操作分别写为**P(S)、V(S)**。

### 整型信号量   
* 用一个**整数型**的变量作为信号量，用来表示系统中的某种资源的数量。
  
* 它的操作只有三种（**初始化，P操作、V操作**）   
```C++
int S = 1; //初始化整型信号量S，表示系统中可用打字机的数量
void wait(int S){   //wait 原语 相当于进入区
  while(S <= 0)     //如果资源不够 循环等待
    ;
  S = S - 1;        //资源数量够 占用一个资源
}
void signal(int S){ //signal 原语 相当于退出区
  S = S + 1;        //使用完资源，在退出区释放资源
}
```
![20230209111329](https://cdn.jsdelivr.net/gh/jamie109/my-img/for-VSCode/20230209111329.png)  

* 检查、上锁一气呵成，避免了并发、异步导致的问题

* 不满足**“让权等待”**，会发生忙等。卡在wait原语的while循环。
  
### 记录型信号量（高频出题点）   
整型信号量会发生忙等，不满足“让权等待”原则。为此，提出了“记录型信号量”，用记录型数据结构表示的信号量。

![20230209115446](https://cdn.jsdelivr.net/gh/jamie109/my-img/for-VSCode/20230209115446.png)

* 在剩余资源数不够的情况下，**block原语，使进程从运行态进入阻塞态，并把它挂到信号量的等待队列（即阻塞队列）中**   
* 释放资源后，若还有别的进程在等待这种资源，**wakeup原语，唤醒等待队列中的一个进程（从阻塞态到就绪态）**
  
>关于if语句的条件：对wait原语，**是进程p先占下一个资源，** 此时p肯定有一个资源（不管这个资源能不能真的用上），如果此时剩余的资源数小于0，那就说明在p没占资源的时候，资源数小于等于零（小于零是指有别的进程在等它），p肯定是无法用这个资源的，所以要阻塞掉p。   
>对signal原语，p用完了资源，把它释放，**此时资源已经释放了**，然后去看看有没有进程等着用它。条件是value小于等于零，也就是说在p没释放的时候，value小于零，真的有进程在等它，所以要找个在等待的进程把它叫醒，告诉它你可以用这个资源了。
  
## 5.用信号量实现进程互斥、同步、前驱关系   
### 实现进程互斥  
1. 分析并发进程的关键活动，划定**临界区**（只有一个资源，只允许一个进程访问）   
2. 设置**互斥信号量**mutex，**初始化为1**    
3. 在使用临界资源之前执行P(mutex)   
4. 在使用临界资源之前执行V(mutex)
   
```C++
// 这是记录型信号量 如果题目没有特殊说明 可以如下简写
semaphore mutex = 1; //初始化为1
P1(){ // P2进程和P1一样
  ...
  P(mutex); // 加锁
  临界区代码...
  V(mutex); //解锁
  ...
}
```

* 跟上一小节的“记录型信号量（高频出题点）”是一样的   
* **对不同的临界资源要设置不同的互斥信号量**（起别的变量名）
  
### 实现进程同步   
进程同步，要求个并发进程按照要求**有序**地推进。   
1. 什么地方需要同步关系（哪里需要保证“一前一后”地执行两个操作）   
2. 设置同步信号量S，**初始为0**   
3. **在“前操作”之后执行V(S)**   
4. **在“后操作”之前执行P(S)**   
   
![20230209124913](https://cdn.jsdelivr.net/gh/jamie109/my-img/for-VSCode/20230209124913.png)

> 对后操作(代码4)来说，你要执行代码4，就肯定需要先执行P(S)。而在P(S)中，需要将S减一，因为S初始化是0，减一之后就为负了，没法继续执行。除非此时V(S)已经执行过了（它是将S加一的），如果V(S)已经执行过了，那么代码2肯定执行过了。就保证了代码2在代码4之前执行。

### 实现进程前驱    
![20230209124951](https://cdn.jsdelivr.net/gh/jamie109/my-img/for-VSCode/20230209124951.png)  

> 把很多代码之间的顺序关系简化为很多个**两个代码之间顺序**，然后分别对每一对代码进行**进程同步**   


> thanks for [B站王道计算机教育](https://www.bilibili.com/video/BV1YE411D7nH?p=8&spm_id_from=pageDriver&vd_source=38881132948112534788036151fc388f)

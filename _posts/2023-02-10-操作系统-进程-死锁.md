---
layout: post
title: "[操作系统]进程：死锁"
date: 2023-02-10 16:14 +0800
author: jamie109
categories: [CS_course, OS]
tags: [CS course note, wangdao]
mermaid: true
---
## 1.管程   
### 引入管程   
信号量机制存在问题：编写程序困难、易出错（比如写错了互斥P和同步P的顺序）管程是一种高级的同步机制。   
* 需要定义和共享资源相关的数据结构   
* 需要定义对数据结构进行操作的函数   
* 为共享数据设置初始值   
* 管程有一个名字   
**管程的定义有点像类。**

1. 管程中的共享数据结构只能被管程内部的过程（函数）访问    
2. ​一个进程只能通过调用管程内的过程（函数）才能访问管程内的数据   
3. **每次仅允许一个进程在管程内执行某个内部过程（函数）**，保证每次访问数据结构只有一个进程

![20230210162408](https://cdn.jsdelivr.net/gh/jamie109/my-img/for-VSCode/20230210162408.png)  
由编译器负责实现各进程互斥地进入管程地过程，使用管程，不用自己去考虑，实现进程互斥和同步就简单多了。

## 2.死锁   
死锁是由于**并发**环境下，各进程因为竞争资源造成的：**互相等待对方手里的资源，导致各进程都阻塞**，无法向前推进的现象。

![20230210192657](https://cdn.jsdelivr.net/gh/jamie109/my-img/for-VSCode/20230210192657.png)

产生死锁的四个条件，必须同时满足：  
1. 只有必须互斥使用的资源才会导致死锁   
2. 不可剥夺条件，进程获得的资源不能被别人抢走   
3. 请求和保持条件，进程以及至少保持了一个资源，但又提出了新的资源请求，而它想要的资源被其他进程占有。就是我拥有的资源谁也不给，但我还想要别人的资源。   
4. 循环等待条件，死锁时存在循环等待链，链中的每个进程拥有的资源同时被下一个进程想要。但是存在循环等待链不一定出现死锁（同类资源大于1，可能链条外的某个进程释放了资源）。  

对死锁的处理：预防，破坏产生死锁的条件。避免死锁，避免系统进入不安全状态（银行家算法）。死锁的检测和解除，允许死锁发生，操作系统负责检测死锁并解除。 

## 3.死锁的解决   
## 预防死锁  
破坏死锁产生的四个条件（互斥条件、、、）。  
1. 互斥条件，只有对必须互斥使用的资源才会导致死锁。  
   把只能互斥使用的资源改造为允许共享使用的。  
   缺点：不是所有的互斥都能改共享。

2. 不剥夺条件，进程所获得的资源在未使用完之前，不能由其他进程抢走。  
   方案一：某个进程所需的资源得不到满足时，主动释放自己保持的资源，以后再重新申请   
   方案二：操作系统协助，将资源剥夺给优先级高的资源   
   缺点：实现复杂。可能造成获得资源前一阶段的工作白做。反复申请资源增加系统开销。只要得不到就得放弃，如果一直这样，就会导致进程饥饿。

3. 破坏请求和保持条件   
   静态分配法：进程分配好需要的资源再投入运行，运行时不再申请。   
   实现简单，但是资源利用率极低，可能导致某些进程饥饿。  

4. 循环等待条件  
   顺序资源分配法：首先给系统资源编号，每一个进程必需按照进程递增的顺序请求资源（大编号无法请求小编号资源，也就不能线程循环等待的情况）。   
   按编号申请资源，编程很麻烦。不方便添加新设备，需要重新分配编号。进程实际使用资源的顺序可能和编号顺序不一致，导致需要提前申请不必要的资源导致浪费​。

> 0210，今天不在状态，OS学不下去，明天返校在看。   
> 0212，continue。

### 避免死锁（银行家算法，重要）   
安全序列：系统按照这种序列分配资源，能让每个进程都顺利完成。只要存在一个安全序列，系统就是**安全状态**，安全序列可能有多个。  
找不到安全序列，系统就是不安全状态，意味着可能所有进程都无法顺利执行下去（如果有进程提前归还资源，那系统也有可能可以回到安全状态）
**不安全状态可能发生死锁**（不一定发生），安全状态一定不会死锁。

**在分配资源之前预先判断这次分配是否会导致系统进入不安全状态，以此决定是否答应资源分配请求。**这就是“银行家算法”的思想。  
![20230212102416](https://cdn.jsdelivr.net/gh/jamie109/my-img/for-VSCode/20230212102416.png)   

![20230212102540](https://cdn.jsdelivr.net/gh/jamie109/my-img/for-VSCode/20230212102540.png)  

### 死锁的检测和解除  

#### 死锁检测(常考)    
![20230212103216](https://cdn.jsdelivr.net/gh/jamie109/my-img/for-VSCode/20230212103216.png)   
如果系统中剩余的可用资源数足够满足进程的需求，那么进程暂时不会阻塞，可以顺利进行。进程执行结束，把进程（圆形表示的）跟它相连的边删掉，资源还给系统，那么其他阻塞的进程可能会激活。    
如果最终能消除所有边，一定没有发生死锁。如果不能，此时发生了死锁。**最终`还连着边的进程`就是处于死锁状态的进程。**   
![20230212103953](https://cdn.jsdelivr.net/gh/jamie109/my-img/for-VSCode/20230212103953.png) 

#### 死锁解除    

![20230212110346](https://cdn.jsdelivr.net/gh/jamie109/my-img/for-VSCode/20230212110346.png)

![20230212110637](https://cdn.jsdelivr.net/gh/jamie109/my-img/for-VSCode/20230212110637.png)  

> thanks for [B站王道计算机教育](https://www.bilibili.com/video/BV1YE411D7nH?p=8&spm_id_from=pageDriver&vd_source=38881132948112534788036151fc388f)
 
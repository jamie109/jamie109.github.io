---
layout: post
title: CPU如何选择线程
date: 2023-09-24 21:20 +0800
categories: [CS_course, OS]
tags: [OS]
mermaid: true
math: true
---

系统中需要运行的**多线程数一般都会大于 CPU 核心**，这样就会导致线程排队等待 CPU，这可能会产生一定的延时，如果任务对延时容忍度很低，则可以通过一些人为手段干预 Linux 的默认调度策略和优先级。

## 1、线程

在 Linux 内核中，**进程和线程都是用 task_struct 结构体表示的**，区别在于线程的 task_struct 结构体里部分资源是共享了进程已创建的资源，比如内存地址空间、代码段、文件描述符等，所以 Linux 中的线程也被称为轻量级进程，因为线程的 task_struct 相比进程的 task_struct **承载的资源比较少**，因此以**轻**得名。

一般来说，没有创建线程的进程，是只有单个执行流，它被称为是主线程。如果想让进程处理更多的事情，可以创建多个线程分别去处理，但不管怎么样，它们对应到内核里都是 task_struct。

Linux 内核里的调度器，调度的对象就是 task_struct，也称为任务。任务的优先级的数值越小，优先级越高。

- 实时任务，对系统的响应时间要求很高，**要尽可能快的执行实时任务**。
- 普通任务。


## 2、完全公平调度CFS（Completely Fair Scheduling）

对于普通任务来说，公平性最重要。

1. 为每个任务安排一个**虚拟运行时间 vruntime，如果一个任务在运行，其运行的越久，该任务的 vruntime 自然就会越大**，而没有被运行的任务，vruntime 是不会变化的。
2. 在同样的实际运行时间里，**高权重任务的 vruntime 比低权重任务的 vruntime 少**。（考虑到优先级）
3. 在 CFS 算法调度的时候，会**优先选择 vruntime 少**的任务，以保证每个任务的公平性。

## 3、运行队列

每个 CPU 都有自己的运行队列（Run Queue, rq），用于描述在此 CPU 上所运行的所有进程，其队列包含三个运行队列，Deadline 运行队列 dl_rq、实时任务运行队列 rt_rq 和 CFS 运行队列 cfs_rq，其中 **cfs_rq 是用红黑树来描述的，按 vruntime 大小来排序的，最左侧的叶子节点，就是下次会被调度的任务**。

这几种调度类是有优先级的，优先级如下：Deadline > Realtime > Fair，**实时任务总是会比普通任务优先被执行。**

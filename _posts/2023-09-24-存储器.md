---
layout: post
title: 存储器
date: 2023-09-24 10:59 +0800
categories: [CS_course, OS]
tags: [OS]
mermaid: true
math: true
---

## 1、层次结构

- 寄存器
- CPU Cache（L1、L2、L3）
- 内存
- 硬盘

### 寄存器

32 位 CPU 中大多数寄存器可以存储 4 个字节。

寄存器的访问速度非常快，一般要求在半个 CPU 时钟周期内完成读写。

### Cache

CPU Cache 用的是一种叫 SRAM（Static Random-Access Memory，静态随机存储器） 的芯片，**只要有电，数据就可以保持**，一旦断电，数据就会丢失。

CPU 的高速缓存，通常可以分为 L1、L2、L3 这样的三层高速缓存，也称为一级缓存、二级缓存、三级缓存。

1. L1

**每个 CPU 核心都有一块属于自己的 L1 高速缓存**，指令和数据在 L1 是分开存放的，所以 L1 高速缓存通常分成指令缓存和数据缓存。

2. L2

**L2 高速缓存同样每个 CPU 核心都有**，但是 L2 高速缓存位置比 L1 高速缓存距离 CPU 核心 更远，它大小比 L1 高速缓存更大，访问速度则更慢。

3. L3

L3 高速缓存通常是**多个 CPU 核心共用**的，位置比 L2 高速缓存距离 CPU 核心 更远，大小也会更大些，访问速度相对也比较慢一些。

### 内存

内存使用的是一种叫作 DRAM （Dynamic Random Access Memory，动态随机存取存储器） 的芯片，数据会被存储在电容里，电容会不断漏电，所以需要「定时刷新」电容，才能保证数据不会被丢失，这就是 DRAM 之所以被称为「动态」存储器的原因，只有**不断刷新，数据才能被存储起来**。

### 硬盘

SSD硬盘结构和内存类似，但是它相比内存的优点是**断电后数据还是存在**的，而内存、寄存器、高速缓存断电后数据都会丢失。

HDD，机械硬盘，已经被SSD淘汰。

### 总结

- 存储空间越大的存储器设备，其访问速度越慢，所需成本也相对越少。

- CPU 并不会直接和每一种存储器设备直接打交道，而是**每一种存储器设备只和它相邻的存储器设备打交道**。
- 不同的存储器之间性能差距很大，构造存储器分级很有意义，分级的目的是要构造缓存体系。

## 2、CPU Cache 的数据结构和读取过程

CPU Cache 是由很多个缓存块 Cache Line 组成的，Cache Line 是 CPU **从内存读取数据的基本单位，而 Cache Line 是由各种标志（Tag）+ 数据块（Data Block）组成**。CPU Cache 的数据是从内存中读取过来的，它是以一小块一小块读取数据的。

CPU 读取数据的时候，无论数据是否存放到 Cache 中，CPU 都是先访问 Cache，只有当 Cache 中找不到数据时，才会去访问内存，并把内存中的数据读入到 Cache 中，CPU 再从 CPU Cache 读取数据。

CPU 怎么知道要访问的内存数据，是否在 Cache 里？如果在的话，如何找到 Cache 对应的数据呢？

### 直接映射

把内存块的地址**映射**在一个 CPU Cache Line（缓存块） 的地址，**使用取模运算**，运算的结果就是内存块地址对应的缓存块的地址。

为了区别不同的内存块，在对应的 CPU Cache Line 中还会存储一个**组标记（Tag）**，记录当前 CPU Cache Line 中存储的数据对应的内存块。

**有效位（Valid bit）**，用来标记对应的 CPU Cache Line 中的数据是否是有效的，如果有效位是 0，无论 CPU Cache Line 中是否有数据，CPU 都会直接访问内存，重新加载数据。


一个内存的访问地址，包括组标记、CPU Cache Line 索引、偏移量这三种信息；缓存块由**索引 + 有效位 + 组标记 + 数据块**组成。

CPU 访问一个内存地址的时候，会经历这 4 个步骤：

1. 根据内存地址中索引信息，计算在 CPU Cache 中的索引，也就是找出对应的 CPU Cache Line 的地址；
2. 找到对应 CPU Cache Line 后，判断 CPU Cache Line 中的**有效位**，确认 CPU Cache Line 中数据是否是有效的，如果是无效的，CPU 就会直接访问内存，并重新加载数据，如果数据有效，则往下执行；
3. 对比内存地址中组标记和 CPU Cache Line 中的**组标记**，确认 CPU Cache Line 中的数据是我们要访问的内存数据，如果不是的话，CPU 就会直接访问内存，并重新加载数据，如果是的话，则往下执行；
4. 根据内存地址中偏移量信息，从 CPU Cache Line 的数据块中，读取对应的字。

### 缓存一致性问题

- 写传播，总线嗅探。
- 事务的串行化，MESI 协议。
  - Modified，已修改
  - Exclusive，独占
  - Shared，共享
  - Invalidated，已失效

### 伪共享

因为多个线程同时读写同一个 Cache Line 的不同变量时，而导致 CPU Cache 失效的现象称为伪共享。

对于多个线程共享的热点数据，即经常会修改的数据，应该**避免这些数据刚好在同一个 Cache Line 中**，否则就会出现为伪共享的问题。

避免 Cache 伪共享实际上是用**空间换时间**的思想，浪费一部分 Cache 空间，从而换来性能的提升。
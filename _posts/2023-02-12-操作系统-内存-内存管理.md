---
layout: post
title: "[操作系统]内存：内存管理"
date: 2023-02-12 11:10 +0800
author: jamie109
categories: [CS_course, OS]
tags: [CS course note, wangdao]
mermaid: true
math: true
---
## 1.内存   
### 什么是内存   
程序执行前需要先放到内存中才能被CPU处理。内存地址从0开始，每一个地址对应一个**存储单元**。   
如果**按字节编址**，一个存储单元1字节（即1B），8个二进制位；如果**按字长编址**，一个存储单元1个字长，字长16位的计算机一个存储单元16个二进制位。不同计算机字长不一样。   
### 常用的数量单位   
$2^{10}=1K$    
$2^{20}=1M$   
$2^{30}=1G $  
4G内存的地址长度: $4*2^{30}=2^{32}$，所以需要32个二进制位(32位操作系统最大支持4GB内存，指针大小4字节)    
### 进程运行原理——指令   
CPU按照程序段的指令去内存某个位置存取数据，一条指令由操作码+若干参数组成，编译生成的指令中一般使用**逻辑地址**。  
逻辑地址：相对地址    
物理地址：绝对地址   
编译时产生的指令只关心相对地址，实际放入内存中再想办法根据起始位置得到绝对地址。
### 从写程序到程序运行   
![20230212141415](https://cdn.jsdelivr.net/gh/jamie109/my-img/for-VSCode/20230212141415.png)   
链接结束，形成完整的逻辑地址。

* 三种链接方式   
  1. 静态链接，装入前链接成一个完整模块    
  2. 装入时动态链接，运行前边装入边链接    
  3. 运行时动态链接，运行时需要这个目标模块时才装入并链接，便于修改和更新，便于实现对目标模块的共享。
   
* 三种装入方式   
  1. **绝对装入**   
    编译时产生绝对地址，只适用于**单道**程序环境(那时候还没有操作系统，编译器负责实现)。   
  2. **可重定位装入(静态重定位)**    
    编译链接后的装入模块地址是逻辑地址，**装入时进行重定位，将指令中逻辑地址+装入的起始物理地址 → 真实的物理地址**    
    特点：作业装入内存时，必需分配其要求的**全部内存空间**，内存不够就不能装入。作业一旦进入内存，运行期间就不能再移动，也不能再申请内存空间，因为地址都写死了。早期多道批处理操作系统使用。
  3. **动态运行时装入(动态重定位)**    
    编译、链接后的装入模块的地址都是从0开始的，装入内存后不会立即把逻辑地址转换为物理地址，而是**真正要执行时才将逻辑地址转换为物理地址**。    
    需要设置**重定位寄存器**(或者叫基址寄存器)。**允许程序在内存中发生移动**（只需要改变重定位基址寄存器），而且程序可以分配到不连续的储存区，也支持动态申请内存。只需装入部分代码即可投入运行，可以向用户提供一个比存储空间大得多的地址空间。现代操作系统使用。

## 2.内存管理的概念   
![20230212143416](https://cdn.jsdelivr.net/gh/jamie109/my-img/for-VSCode/20230212143416.png)  

## 3.覆盖与交换   
### 覆盖技术   
思想：将程序分为多个段（多个模块），常用的段常驻内存，不常用的段在需要时调入内存。   
内存中分一个**固定区**（放置需要常驻内存的段，调入后就不再调出，除非运行结束）、多个**覆盖区**（需要时调入不需要时调出）。   
![202302121445245](https://cdn.jsdelivr.net/gh/jamie109/my-img/202302121445245.png)  
### 交换技术   
思想：在内存空间紧张时，将内存中某些进程暂时换出外存，把外存中已具备运行条件的进程换入内存（进程在内存与磁盘间动态调度）。   

中级调度（内存调度）

进程的PCB常驻内存，它需要记录该进程在外存中的位置，到时候去哪里找它。  
* 磁盘中什么位置保存被换出的进程？    
  磁盘分为对换区(swap)和文件区，前者连续分配追求I/O速度，被换出的进程放到这里，速度比文件区快。文件区离散分配追求存储空间利用率。   
* 什么时候应该交换？   
  通常在需要进程运行且内存吃紧时进行。
* 应该换出哪些进程？   
  优先换出阻塞进程、低优先级进程（可能导致饥饿）、还要考虑进程在内存的驻留时间，PCB不会换出。
  
## 4.连续分配管理方式   
为用户进程分配的内存必须是一个连续的内存空间。  
### 单一连续分配   
![Snipaste_2023-02-12_15-40-06](https://cdn.jsdelivr.net/gh/jamie109/my-img/for-VSCode/Snipaste_2023-02-12_15-40-06.png)   

### 固定分区分配   
![20230212154926](https://cdn.jsdelivr.net/gh/jamie109/my-img/for-VSCode/20230212154926.png)   
![20230212155211](https://cdn.jsdelivr.net/gh/jamie109/my-img/for-VSCode/20230212155211.png)

### 动态分区分配   
又称为可变分区分配，不会预先划分内存分区，而是进程装入内存时，根据进程的大小动态地建立分区，使分区大小正好适合进程的需要。   
* 数据结构记录内存使用情况   
  ![20230212155858](https://cdn.jsdelivr.net/gh/jamie109/my-img/for-VSCode/20230212155858.png)   
* 如何选择分区   
   这个算法后面会讲

  ![20230212161143](https://cdn.jsdelivr.net/gh/jamie109/my-img/for-VSCode/20230212161143.png)   
* 分区的分配与回收   
  有相邻的空闲分区就合并。

![20230212161627](https://cdn.jsdelivr.net/gh/jamie109/my-img/for-VSCode/20230212161627.png)   

## 5.动态分区分配算法   
###  首次适应(First Fit)   
从低地址开始查找，空闲分区**按地址递增顺序**排列，每次分配内存时查找空闲分区链(表)，找到第一个满足要求的分区。
每次从低地址部分查找，高地址的大分区更有可能被保存下来。低地址留下很多小分区，但查找的时候还要查找这些，会浪费时间。

###  最佳适应(Best Fit)   
空闲分区**按容量递增顺序**链接，每次分配内存时按顺序查找内存分区链(表)，找到第一个可以满足的空闲分区。
优先使用最小连续内存区，尽可能多的留下大块空闲区，满足大进程需求，但是会留下非常多难以利用的外部碎片。

###  最坏适应(Worst Fit)   
又称最大适应算法(Largest Fit)​空闲分区**按容量递减顺序**排序，每次分配找到能满足要求的第一个空闲分区。**优先使用最大的连续空闲区**，使得分配后的剩余空闲区不会太小，方便使用，但是如果后面需要大内存区间就没办法了。

###  邻近适应(Next Fit)   
又叫循环首次适应算法，空闲分区按地址递增顺序构成循环链表，每次内存分配时**从上次查找结束位置开始，找到第一个能满足要求的空闲分区。**
无论是低地址还是高地址的空闲分区，都**有相同的概率被使用**，导致最后无大分区可用。

![20230212163141](https://cdn.jsdelivr.net/gh/jamie109/my-img/for-VSCode/20230212163141.png)

> thanks for [B站王道计算机教育](https://www.bilibili.com/video/BV1YE411D7nH?p=8&spm_id_from=pageDriver&vd_source=38881132948112534788036151fc388f)
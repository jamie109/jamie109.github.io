---
layout: post
title: 聚类
date: 2023-03-10 10:25 +0800
author: jamie109
categories: [CS_course, Big Data Computing]
mermaid: true
math: true
---

聚类是对点集进行考察并按照某种距离测度将它们聚成多个＂簇＂的过程。聚类的目标是使得同一簇内的点之间的距离较短，而不同簇中点之间的距离较大。

# 1. 层次法    
## 两种方式    
* 自上至下，初始把所有点看作一个聚类，不断分割。     
* 自下至上，初始把每个点看作一个聚类，通过合并两个小簇而形成一个大簇。  
      
## 自下至上     
### 簇如何表示？  
合并聚类时，需要表示每个聚类的位置，来判断哪两个聚类离得最近。

在欧式空间中，可以通过这一簇点的中心点的坐标来代表这一聚类（坐标取平均）。      
但很多情况下无法求平均值（在非欧空间下，当无法合并簇中的点时），这时选择一个簇中**实际存在的点**作为这个聚类的中心——簇中心点。几种选择簇中心点的方法：    
* (1) 该点到簇中其他所有点的距离之和（求和）；     
* (2) 该点到簇中另外一点的最大距离（最大值）；      
* (3) 该点到簇中其他所有点的距离平方和（平方和）。

基本的层次聚类算法效率不高。在每一步当中，为了得到最佳合并，必须计算所有簇之间的距离，算法时间复杂度是 $O(n^{3})$ 。

## 自上之下（经典算法K-means）      
普适算法。
假定在欧氏空间下，最终簇的数目K事先已知。    
### 算法思路    
首先选择K个点作为初始聚类。算法的核心是for循环部分，该循环中考虑将**K个选择点之外的每个点**分配给最近的簇，这里的“最近”指**离簇的质心最近**。需要注意的是，当点分配到簇之后簇的质心可能会漂移。但是由于只有簇附近的点才可能会被分配给自己，所以簇的质心也不会移动太大。 

```C
Initially choose k points that are likely to be in 
    different clusters;
Make these points the centroids of their clusters; 
FOR each remaining point p DO 
    find the centroid to which pis closest; 
    Add p to the cluster of that centroid; 
    Adjust the centroid of that cluster to account for p;
    END;
```
   
### 选择正确的K值    
尝试不同的K，如果能够在不同的K下对聚类结果的质量进行评价。变化最快的位置就是正确的K（斜率最大的），之后变化缓慢了。

![20230310110407](https://cdn.jsdelivr.net/gh/jamie109/my-img/for-VSCode/20230310110407.png){: width="330"}

### 代表簇的K个初始点选择  
现在还没有统一的方法。

## BFR算法    

针对某种特殊情况，BFR算法对簇的形状给出了一个非常强的假设，即它们必须以满足以质心为期望的正态分布。一个簇的在不同维度的均值和标准差可能不同，但是维度之间必须相互独立。对于BFS算法，除了重心，还要加一个标准差。

在BFR算法中，有三个集合，有一个点来了，要先判断这个点属于哪个集合。   

* (1) 废弃集 (Discard Set) 该集合由簇本身的简单概要信息组成。我们将简要介绍簇概要的这种形式。需要注意的是，簇概要本身没有被“废弃”，它们实际上不可或缺。然而，概要所代表的点已被废弃，它们在内存中除了通过该概要之外已经没有其他表示信息。     
* (2) 压缩集 (Compressed Set) 类似于簇概要信息，压缩集中放的也是概要信息，所不同的是，压缩集中只存放那些相互接近的点集的概要，而不是接近任何簇的点集的概要。压缩集所代表的点也被废弃，从这个意义上说，它们也不会显式地出现在内存中。我们将代表点的集合称为迷你簇 (minicluster)。     
* (3) 留存集 (Retained Set) 留存集上的点既不能分配给某个簇，也不会和某个其他点充分接近而被放到压缩集中。这些点在内存中会与其在输入文件中一样显式存在。

1. 先确定K值，K个中心。    
2. 来一个点，计算这个点到K个聚类质心的最小距离。如果这个距离在某个阈值之下，就把它放到DS集合。如果距离超过阈值，但它周围有离得近的点，那么这些点可能构成新的聚类，就把这些点放到CS集合。如果超过了阈值周围又没有离得近的点，就把它放到RS集合。   
3. 如果新的点加入某个聚类，就要更新重心，标准差，这个计算很大。所以不直接算，把平均值和方差分成三个数据（点的数量N，向量之和SUM，每个点的平方和SUMSQ），这三个数据可以推出平均值和方差。

马氏距离，本质上是点到簇质心的距离，并在每维通过簇的标准差进行归一化。由于BFR算法 假定簇的坐标和空间的坐标保持一致，因此马氏距离的计算特别简单。令点 $p = [p_{1},P_{2}, ···,p_{d}]$, C = [c_{1}, C_{2}, …, C_{d}]$ 是某个簇的质心。又令O'是簇中点在第i维上的标准差，则p和c之间的马氏距离为   
![20230310113737](https://cdn.jsdelivr.net/gh/jamie109/my-img/for-VSCode/20230310113737.png){: width="150"}

为将点p分配给某个簇，计算p和每个簇质心的马氏距离，选择那个质心具有最短马氏距离的簇，并当该距离小于某个阙值时将该点加入簇中。

# 2. 点分配法

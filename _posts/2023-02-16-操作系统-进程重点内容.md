---
layout: post
title: "[操作系统]进程重点内容"
date: 2023-02-16 19:53 +0800
author: jamie109
categories: [CS_course, OS]
tags: [CS course note]
mermaid: true
math: true
---
## 1.进程VS线程    

![20230216195923](https://cdn.jsdelivr.net/gh/jamie109/my-img/for-VSCode/20230216195923.png)    
* 进程: OS为正在运行的程序提供的抽象     
  * 并发性: 每个进程顺序执行一系列指令流 (代码段)     
  * 保护性: 每个进程具有独立的内存空间
  
* 线程: OS为正在运行的程序提供的并发性抽象, 它可以被理解为轻量级进程     
  * 一个线程代表一组顺序执行的指令序列 (a.k.a, 任务)    
  * OS可以像对进程一样, 创建、挂起、恢复、运行线程     
  * 一个线程必须从属于某一个进程, 由线程ID, PC, 寄存器集合和堆栈组成, 是基本的CPU执行单元 (它不拥有系统资源)     
  * 属于同一个进程的多个线程相互共享进程资源且是互信的 (i.e., 线程解耦了并发性和保护性)

**引入线程后,进程将只作为除CPU外的系统资源的分配单元，线程则作为CPU调度单元 (同一地址空间内的上下文切换代价较小)**    

### 什么是线程，举个进程和线程的例子      
线程是操作系统调度的最小单位，是进程中的一个执行单元。一个进程可以包含多个线程，这些线程共享进程的内存空间和其他资源。

一个进程可以看做是一个运行的程序实例，它包括代码、数据和系统资源，例如文件、套接字、IPC机制等。一个线程是进程中的一个执行单元，它包含一个线程栈、寄存器和一个指令指针。线程之间可以并发执行，共享同一进程的内存空间和其他资源。

下面是一个**进程和线程的例子**：

假设你要写一个文本编辑器，这个编辑器需要同时进行多个操作，例如打开文件、保存文件、复制粘贴、查找替换等。你可以把这个编辑器作为一个进程，包含所有的代码、数据和资源。同时，你可以使用多个线程来实现这些操作，例如使用一个线程负责打开文件，另一个线程负责保存文件，另一个线程负责处理用户的输入，等等。这些线程可以并发执行，共享同一进程的内存空间，从而提高系统的响应速度和用户体验。

在这个例子中，进程表示整个编辑器应用程序，线程表示执行不同操作的不同执行单元。通过使用多个线程，可以在单个进程中并发执行多个操作，从而提高编辑器的响应性能和用户体验。

## 2.进程的生命周期     
![20230216200132](https://cdn.jsdelivr.net/gh/jamie109/my-img/for-VSCode/20230216200132.png){: width="400"}     
* 操作系统为什么设计僵尸进程    
  操作系统设计僵尸进程的主要原因是为了确保进程资源的释放和维护。当一个进程完成执行后，它的资源（如内存、文件描述符等）并没有立即被操作系统回收，而是留给其父进程处理。如果没有僵尸进程，父进程就无法获取到子进程的退出状态，也就无法释放子进程占用的资源，这会导致资源泄露和系统性能下降。

  因此，操作系统设计了僵尸进程机制，当一个子进程结束时，它的进程描述符并不会立即从内核中删除，而是保留一段时间，直到父进程通过wait或waitpid等系统调用获取到子进程的退出状态后再将其删除。在这段时间内，子进程的状态被标记为“僵尸”（Zombie），表示它已经结束执行，但是其退出状态还未被父进程处理。当父进程调用wait或waitpid等系统调用获取子进程的退出状态后，操作系统就会删除僵尸进程的进程描述符，并释放它占用的资源。

  虽然僵尸进程本身并不执行任何代码，但它是操作系统中重要的一部分，可以确保进程资源的释放和维护。因此，操作系统需要设计僵尸进程来保证系统的正常运行。   




## 3.进程切换    
![20230216203943](https://cdn.jsdelivr.net/gh/jamie109/my-img/for-VSCode/20230216203943.png){: width="500"}

* 一个进程A从运行态到就绪态/阻塞态，另一个进程B从就绪态到运行态      
* 保存进程A的内核态寄存器到A的PCB     
* 用进程B的PCB为内核态寄存器赋值     
* 根据CS:IP跳转 

### lcr3函数    
在操作系统中，当进行进程切换时，需要更改页目录表的物理地址，因此就需要使用 "lcr3" 指令将新的页目录表地址加载到CR3寄存器中。

在Linux内核中，"lcr3" 函数是用C语言编写的一个内联汇编函数，用于更新CR3寄存器的值。这个函数通常会在内核启动时被调用，以便将初始的页表地址加载到CR3寄存器中。

以下是 "lcr3" 函数的伪代码：

```C
void lcr3(uint32_t val) {
    asm volatile("mov %0, %%cr3" : : "r" (val));
}
```
其中，"mov %0, %%cr3" 是内联汇编指令，将变量 val 的值加载到CR3寄存器中。"r" (val) 是输入约束，表示将变量 val 放在寄存器中，%0是输出约束，表示使用第一个输入操作数作为输出操作数。


### switch_to函数    

context是一个包含了一些寄存器值、堆栈指针等信息的结构体，它描述了进程当前的执行状态。

switch_to 函数接受两个参数：prev 和 next，分别表示前一个进程和下一个进程。它的作用是将当前 CPU 的执行上下文从前一个进程切换到下一个进程。在切换过程中，switch_to 函数会完成以下几个主要任务：

保存当前进程的执行上下文，包括程序计数器、堆栈指针、CPU 寄存器等。

将前一个进程的状态设置为“就绪”状态，并将其添加到就绪队列中。

将下一个进程的状态设置为“运行”状态，并从就绪队列中移除它。

恢复下一个进程的执行上下文，包括程序计数器、堆栈指针、CPU 寄存器等。

返回下一个进程的线程信息结构体指针。

switch_to 函数是在内核态下执行的，因此它可以直接访问内核数据结构和进程控制块（PCB）等数据。它是进程调度中一个非常重要的函数，可以让不同的进程在 CPU 上轮流运行，从而实现多任务并发执行的效果。

### 为什么进程切换时lcr3函数在swith_to函数之前执行    
在进行进程切换时，操作系统需要做很多事情，其中一个重要的步骤是设置新进程的内存环境。这个环境包括进程的页表，它决定了进程虚拟地址空间中各个地址对应的物理内存位置。而lcr3函数的作用是更改CPU使用的页表基地址，以便CPU使用新进程的页表。

在Linux内核中，进程切换通常是由调度器完成的，当调度器将CPU分配给一个新进程时，它会调用switch_to函数，该函数负责将CPU的状态切换到新进程的状态，并且切换到新进程的内存环境。由于lcr3函数是更改内存环境的关键步骤之一，因此必须在swith_to函数之前执行。

具体来说，执行顺序通常是：

1. 获取下一个要运行的进程的TCB（任务控制块）结构体。

2. 调用lcr3函数，切换到新进程的页表。     
3. 调用switch_to函数，将CPU的状态切换到新进程的状态，包括堆栈、寄存器等。

总的来说，lcr3函数和swith_to函数的执行顺序是固定的，它们都是进程切换的必要步骤，其中lcr3函数负责更改内存环境，swith_to函数负责将CPU状态切换到新进程的状态。

### 如果先执行swith_to函数再执行lcr3函数，进程切换会出问题吗     
如果先执行switch_to函数再执行lcr3函数，那么就会出现问题，**因为在执行switch_to函数时，CPU的状态已经被切换到了新进程的执行状态，此时新进程已经开始执行，但是新进程的页表并没有被切换到，这样新进程访问虚拟地址空间中的内存时就会出现问题，可能会访问到错误的物理地址，从而导致程序错误、异常或崩溃等问题。**

因此，为了保证进程切换的正确性，必须先执行lcr3函数切换页表，然后再执行switch_to函数切换执行状态，以确保新进程在执行时能够正确访问到自己的虚拟地址空间中的内存。

###  进程切换时发生了中断吗    
>一句话，进程切换是由于OS在多个进程之间调度，进程切换过程中可能发生中断。

在多任务操作系统中，进程切换通常是由操作系统内核来负责完成的，它会通过操作系统调度器来实现。**在进程切换的过程中，确实会涉及到中断的处理**，但是中断并不是进程切换的唯一原因。

在进程切换之前，操作系统会先保存当前进程的上下文信息，包括进程的寄存器状态、程序计数器、堆栈指针等等。这些信息保存在进程的内核栈中。然后，操作系统会根据调度算法选择下一个要执行的进程，并从该进程的内核栈中恢复它的上下文信息。这个过程中，通常会涉及到中断的处理，**因为在切换进程的过程中，可能会发生一些中断事件**，比如时钟中断、I/O中断等等。

当发生中断事件时，CPU会自动将当前进程的上下文信息保存到内核栈中，并跳转到相应的中断处理程序中去执行。中断处理程序会完成中断事件的相应处理，然后再将CPU的控制权交还给操作系统内核。在切换到下一个进程之前，操作系统会先检查是否有更紧急的中断需要处理，如果有，会暂时放弃当前进程的执行权，转而去处理中断事件。

总之，进程切换过程中确实会发生中断，但中断不是进程切换的唯一原因。**进程切换的主要原因是操作系统需要在多个进程之间进行调度，以实现多任务的并发执行。**   


### 上下文切换    

* 中断、异常、系统调用，CPU从用户态栈 → 内核态栈 → 中断栈
* 进程间切换，发生在内核，进程A的PCB → 进程B的PCB

![20230216205737](https://cdn.jsdelivr.net/gh/jamie109/my-img/for-VSCode/20230216205737.png){: width="400"}   
> 简单来说，就是保存p1的信息到PCB1，加载PCB2的信息

![20230216205845](https://cdn.jsdelivr.net/gh/jamie109/my-img/for-VSCode/20230216205845.png){: width="400"}     

**进程上下文切换代价很大(e.g.,地址映射)**。引入线程的目的: 减少程序在并发执行所付出的时空开销,提高OS的并发能力


## 4.多线程同步、互斥   
**临界资源**，多线程共享进程资源，但很多资源一次只能为一个线程使用。例如物理设备都是临界资源，还有被多线程共享的全局变量。     
**临界区**，对临界资源的访问，必须**互斥**地进行，线程访问临界资源的那段代码即为临界区。
互斥指的是对某个系统资源，一个线程正在使用它，另外一个想用它的线程就必须等待，而不能同时使用。     
**竞争条件**，多线程同时进入临界区产生的不可预知的状态，造成不可预知的原因在于**多线程的代码可能会交叉执行**(调度顺序不可知)。    

* 保护临界区最简单的方式: 禁止一切中断发生。     
  原因是CPU只会在发生(I/O、时间)中断时引起任务切换。       
  屏蔽中断可以保证当前运行的线程顺利执行完临界区代码。但是系统执行效率很低, 而且用户可以关中断很危险。    


## 5.死锁VS饿死     
**饿死**: 线程无休止的等待CPU调度

**死锁**: 多个线程环形等待所需的资源     
**死锁必然是一种饿死，但反过来不成立**
 
任何系统或程序在设计时必须保证**deadlock-free**!

出现死锁的四个必要条件:      
* 互斥的共享资源 (Mutual Exclusion Resources)      
* 获得所需资源前不会释放现有资源 (Hold and Wait)      
* 资源不能被抢占 (No Preemption)      
* 环形等待资源 (Circular Wait)

* 死锁防止    
* 死锁避免     
* 死锁检测     
* 鸵鸟算法    
  鸵鸟算法（Ostrich Algorithm）是一种应对死锁问题的应急措施，也称为“头埋在沙子里的算法”。它的基本思想是**当系统进入死锁状态时，不采取任何措施来解除死锁，而是将问题“藏起来”，继续让进程或线程运行下去，当死锁问题严重到一定程度时再采取措施解除死锁。**

  鸵鸟算法的实现方法是，系统在启动时不对资源分配情况进行检查，而是等待死锁发生，当死锁发生时，系统进行重启，并在重启时重新分配资源，从而解除死锁。这种方法虽然不够安全，但是实现简单，成本低，而且不需要进行复杂的死锁检测和解除算法，因此在某些特殊情况下被采用。

  鸵鸟算法的优点在于它可以解决那些发生概率非常小的死锁情况，而且可以避免复杂的死锁检测和解除算法的开销，从而提高系统性能。但是，它的缺点也比较明显，当死锁发生时，系统不能及时解决问题，可能会长时间处于不稳定状态，影响系统性能和用户体验。

  因此，鸵鸟算法通常不被作为解决死锁的首选方案，而是被视为一种备用方案，只在其他解决方案无法解决死锁时才会采用。在实际应用中，我们需要综合考虑系统的安全性、稳定性、性能和成本等因素，选择最适合自己系统的死锁解决方案。    

### 死锁防止、死锁避免、死锁检测和鸵鸟算法，哪种最常用?     
死锁防止、死锁避免、死锁检测和鸵鸟算法这四种方法都是解决死锁问题的方案，但它们各自有不同的应用场景和优缺点，因此在不同的情况下可能会选择不同的方案。

死锁防止是通过限制系统资源的使用来避免死锁的发生，其实现方法是破坏死锁产生的四个条件之一，例如破坏互斥条件、破坏请求与保持条件等。死锁防止的优点是简单易行，可以在系统设计时就考虑死锁的问题，缺点是可能会影响系统的性能和吞吐量。

死锁避免是通过安全地分配资源来避免死锁的发生，其实现方法是利用资源分配状态来预测系统是否会发生死锁，如果发生死锁则不分配资源。死锁避免的优点是可以保证系统的安全性，缺点是需要对系统进行较为复杂的分析和计算，且无法避免所有可能的死锁情况。

死锁检测是在系统发生死锁时通过检测和诊断来解除死锁，其实现方法是定期对系统的资源分配情况进行检测，一旦检测到死锁则采取措施解除死锁。死锁检测的优点是可以及时地解除死锁，缺点是需要消耗一定的计算资源，并且无法避免死锁的发生。

鸵鸟算法是一种应急措施，当系统进入死锁状态时，不采取任何措施来解除死锁，而是将问题“藏起来”，继续让进程或线程运行下去，当死锁问题严重到一定程度时再采取措施解除死锁。鸵鸟算法的优点是实现简单，成本低，缺点是不能及时地解除死锁，可能会长时间处于不稳定状态，影响系统性能和用户体验。

因此，没有一种方法是最常用的，选择使用哪种方法需要根据实际情况来考虑，综合考虑系统的性能、安全性、成本等因素。在实际应用中，通常会采用多种方法结合起来解决死锁问题，例如采用死锁预防措施来尽可能避免死锁的发生，同时定期进行死锁检 








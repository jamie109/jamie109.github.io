---
layout: post
title: const、constexpr、static、volatile、extern、override
date: 2023-10-10 21:56 +0800
categories: [JOB, C++]
tags: [C++]
mermaid: true
math: true
---

## 1、constexpr

C++11中新增加了用于指示**常量表达式**的constexpr关键字。

const和constexpr都可以来修饰对象和函数。

### 修饰对象

- const修饰一个对象表示它是**常量**，不能更改了，允许编译器使用这个特点优化程序。
- constexpr是修饰一个**常量表达式**（constexpr不是修饰常量表达式的唯一途径）
- constexpr包含了const的含义，所以没有必要同时使用const和constexpr
  
> 常量表达式：必须是可以在**编译阶段被识别**的，如模版的参数／数组的大小。

**如果constexpr声明中定义了⼀个指针，constexpr仅对指针有效，和所指对象无关。**也就是说没有const的常量指针和指针常量的区别，constexpr都是指针常量。

const 变量的初始化可以延迟到运行时，而 constexpr 变量必须在编译时进行初始化。所有 constexpr 变量均为常量，因此必须使用常量表达式初始化。

constexpr是一种很强的约束，更好的保证程序的正确定语义不被破坏；编译器可以对constexper代码进行非常大的优化，例如将用到的constexpr表达式直接替换成结果，相比宏来说没有额外的开销。

### 修饰函数

constexpr修饰的函数也有一定的限制：
- 函数的返回类型和所有形参类型都是字面值类型
- 函数体尽量只包含一个return语句，多个可能会编译出错
- 函数体可以包含其他语句，但是不能是运行期语句，只能是编译期语句

编译器会将constexpr函数视为inline函数。所以在编译时若能求出其值，则会把函数调用替换成结果值。

constexpr构造函数必须有⼀个空的函数体，即所有成员变量的初始化都放到初始化列表中。对象调⽤的成员函数必须使⽤ constexpr 修饰。

## 2、const

### 重载

const在类中修饰成员函数（写在参数后面的`<类型标志符>函数名（参数表）const；`），可以作为重载的条件，const是函数类型的一部分，在**实现部分也要带该关键字**。

一个函数名字后有const，这个函数必定是成员函数（普通函数后面不能有const）。**常成员函数不能更新类的成员变量，也不能调用该类中没有用const修饰的成员函数**，只能调用常成员函数。非常量对象也**可以**调用常成员函数，但是如果有重载的非常成员函数则会优先调用非常成员函数。

const作为参数时，只有它**修饰的是指针、引用**时，才能作为重载的条件。`fun(char *a)和fun(const char *a)`，这里加了const，const修饰`*a`，也就是说，**不能通过这个指针去改它所指向位置存储的变量**；引用也是同样的道理。而如果const只是修饰int这种类型数据，由于函数参数值传递，无论函数体里面怎么对int参数修改，都影响不到人家外面的int变量，所以加不加const无所谓。

对于函数的参数，不管是什么数据类型，也不管是指针传递，还是引用传递，只要加了 const 修饰，就可以防止函数内意外修改该参数，起到保护作用。**如果有一个函数参数用const修饰，在函数体中就不能改变这个参数。**

### 迭代器

**STL迭代器**以指针为根据塑模出来，所以迭代器的作用就像个T指针。**声明迭代器为const就像声明指针为const一样**（即声明一个T const 指针），表示这个迭代器**不得指向不同的东西**，但它所指的东西的值是可以改动的。

如果希望迭代器所指的东西不可被改动（即希望STL模拟一个const T* 指针），需要使用const_iterator。

### 函数返回类型

const 作为函数返回类型，最终目的是希望调用函数时**将返回值作为常量**处理。

1. 返回字面常量。`return 100;`
2. 用 const 修饰返回的指针或引用， **返回的是一个右值**，保护**指针或引用的内容不被修改**。`const int*`或者`const int&`，const修饰的实际上是*p、&p，就是地址中存的数据或者被引用的数，所以它们不能修改了。

   **返回值是引用**的函数，可以肯定的是这个引用必然不是临时对象的引用，因此一定是成员变量或者是函数参数，所以在返回的时候为了避免其成为左值被修改，就需要加上const关键字来修饰。

   如果函数的返回类型是**内置类型**如int，修改返回值本身就是**不合法**的。所以 const 返回值是处理返回类型为用户定义类型的情况。

## 3、volatile

- 提醒编译器它定义的变量**随时都有可能改变**，因此编译后的程序每次需要存储或读取这个变量的时候，告诉**编译器对该变量不做优化**。
- 要求每次直接读值，直接从变量**内存地址**中读取数据，从而可以提供对特殊地址的稳定访问。


`for(volatile int i=0; i<100000; i++); `会执⾏，不会被优化掉。


**一个参数可以同时是const和volatile的**。比如只读的状态寄存器。它是volatile因为它可能被意想不到地改变。它是const因为程序不应该试图去修改它。

关键：**随时可以改变**。

## 4、static

static 变量的生命周期是从程序开始到结束。

### 静态局部变量

静态局部变量使用static修饰符定义，即使在声明时未赋初值，编译器也会把它初始化为0。且静态局部变量存储于进程的**全局数据区**，即使函数返回，它的值也会保持不变。

其作用域为**局部作用域**，只有在定义它的函数内部才可以使用。

### 静态全局变量

全局变量定义在函数体外部，在全局数据区分配存储空间，且编译器会自动对其初始化。

**普通全局变量**对整个工程可见，其他文件可以使用extern外部声明后直接使用，也就是说其他文件不能再定义一个与其相同名字的变量了（否则编译器会认为它们是同一个变量）

**静态全局变量仅对当前文件可见**，其他文件不可访问，其他文件可以定义与其同名的变量，两者互不影响。

在定义不需要与其他文件共享的全局变量时，加上static关键字能够有效地降低程序模块之间的耦合，避免不同文件同名变量的冲突，且不会误使用。

### 静态函数

函数返回类型前加上static，就是静态函数。静态函数**只能在声明它的文件中可见，其他文件不能引用该函数**。不同的文件可以使用相同名字的静态函数，互不影响。

### 静态数据成员

静态成员函数属于整个类，而不是某一个对象。要在类中声明，类外初始化，且外部初始化不加static关键字，如`<数据类型><类名>::<静态数据成员名>=<值>`。

- 静态数据成员存储在全局数据区，静态数据成员在定义时分配存储空间，所以不能在类声明中定义
- 类的静态数据成员有两种访问方式：`<类对象名>.<静态数据成员名>` 或 `<类类型名>::<静态数据成员名>`
- 
### 静态成员函数

- 静态成员函数属于整个类，而不是某一个对象。
- 静态成员函数没有this指针，它无法访问属于类对象的非静态数据成员，也无法访问非静态成员函数，它**只能**调用其余的静态成员函数、使用静态成员变量。
- 出现在类体外的函数定义不能指定关键字static
- **非**静态成员函数可以**任意**地访问静态成员函数和静态数据成员

静态成员函数不能为**virtual、const和volatile**，不属于任何类对象或类实例的。

#### virtual

静态与非静态成员函数之间有一个主要的区别。那就是静态成员函数没有this指针。虚函数依靠vptr和vtable来处理。vptr是一个指针，在类的构造函数中创建生成，并且只能用this指针来访问它，因为它是类的一个成员，并且vptr指向保存虚函数地址的vtable。对于静态成员函数，它没有this指针，所以无法访问vptr，无法使用虚函数表。

#### const、volatile

当声明一个非静态成员函数为const时，对this指针会有影响，this指针相当于`Test const *`（**不能修改this指针指向对象**）。而对于非const成员函数，this指针相当于Test *。由于static成员函数没有this指针，所以使用const来修饰static成员函数没有任何意义，volatile同理。

## 5、extern

利用关键字extern，可以使用在函数后边定义的全局变量，可以在一个文件中引用另一个文件中定义的变量或者函数。

利用extern关键字先声明一下变量，告诉编译器，这个变量是存在的，可能在别的地方，编译器一定可以找到，所以我在这里可以使用。

**extern关键字只需要指明类型和变量名，不能再重新赋值**，只是告诉编译器这个东西是存在的。初始化需要在原来的地方进行的，如果不进行初始化的话，全局变量会被编译器自动初始化为0。

引用函数也一样，`extern void func();`，可以引用其他文件中的函数，就不需要在include了，include会把被包含的文件中的所有的变量和方法都可以被这个文件使用，不安全。


## 6、override

写在子类继承了的父类的虚函数的后面，编译器看到有override关键字，**会检查父类的这个函数是不是虚函数**，相当于增加了一种保障机制吧。


[C++11关键字constexpr看这篇就够了](https://blog.csdn.net/yao_hou/article/details/109301290)

[浅谈 C++ 中的 const 和 constexpr](https://zhuanlan.zhihu.com/p/20206577)

[C++中const用于函数重载](https://blog.csdn.net/qq_25800311/article/details/87395467)

[C++中const的强大用法：修饰函数参数/返回值/函数体](https://zhuanlan.zhihu.com/p/256423512)

[C++函数重载(2) - 不能被重载的函数](https://blog.csdn.net/shltsh/article/details/45938663)

[C语言正确使用extern关键字](https://blog.csdn.net/xingjiarong/article/details/47656339)

[C语言丨深入理解volatile关键字](https://zhuanlan.zhihu.com/p/343688629)

[c语言中static关键字用法详解](https://blog.csdn.net/guotianqing/article/details/79828100)

---
layout: post
title: const、constexpr、static、volatile、extern、override
date: 2023-10-10 21:56 +0800
categories: [JOB, C++]
tags: [C++]
mermaid: true
math: true
---

[C++11关键字constexpr看这篇就够了](https://blog.csdn.net/yao_hou/article/details/109301290)

[浅谈 C++ 中的 const 和 constexpr](https://zhuanlan.zhihu.com/p/20206577)

[C++中const用于函数重载](https://blog.csdn.net/qq_25800311/article/details/87395467)

[C++函数重载(2) - 不能被重载的函数](https://blog.csdn.net/shltsh/article/details/45938663)

[C语言正确使用extern关键字](https://blog.csdn.net/xingjiarong/article/details/47656339)

[C语言丨深入理解volatile关键字](https://zhuanlan.zhihu.com/p/343688629)

[c语言中static关键字用法详解](https://blog.csdn.net/guotianqing/article/details/79828100)


## 1、constexpr

C++11中新增加了用于指示**常量表达式**的constexpr关键字。

const和constexpr都可以来修饰对象和函数。

### 修饰对象

- const修饰一个对象表示它是**常量**，不能更改了，允许编译器使用这个特点优化程序。
- constexpr是修饰一个**常量表达式**（constexpr不是修饰常量表达式的唯一途径）
- constexpr包含了const的含义，所以没有必要同时使用const和constexpr
  
> 常量表达式：必须是可以在**编译阶段被识别**的，如模版的参数／数组的大小。

**如果constexpr声明中定义了⼀个指针，constexpr仅对指针有效，和所指对象无关。**也就是说没有const的常量指针和指针常量的区别，constexpr都是指针常量。

const 变量的初始化可以延迟到运行时，而 constexpr 变量必须在编译时进行初始化。所有 constexpr 变量均为常量，因此必须使用常量表达式初始化。

constexpr是一种很强的约束，更好的保证程序的正确定语义不被破坏；编译器可以对constexper代码进行非常大的优化，例如将用到的constexpr表达式直接替换成结果，相比宏来说没有额外的开销。

### 修饰函数

constexpr修饰的函数也有一定的限制：
- 函数的返回类型和所有形参类型都是字面值类型
- 函数体尽量只包含一个return语句，多个可能会编译出错
- 函数体可以包含其他语句，但是不能是运行期语句，只能是编译期语句

编译器会将constexpr函数视为inline函数。所以在编译时若能求出其值，则会把函数调用替换成结果值。

constexpr构造函数必须有⼀个空的函数体，即所有成员变量的初始化都放到初始化列表中。对象调⽤的成员函数必须使⽤ constexpr 修饰。

## 2、const

const在类中修饰成员函数（写在参数后面的`<类型标志符>函数名（参数表）const；`），可以作为重载的条件，const是函数类型的一部分，在**实现部分也要带该关键字**。

常成员函数不能更新类的成员变量，也不能调用该类中没有用const修饰的成员函数，只能调用常成员函数。

非常量对象也**可以**调用常成员函数，但是如果有重载的非常成员函数则会优先调用非常成员函数。

const作为参数时，只有它**修饰的是指针、引用**时，才能作为重载的条件。`fun(char *a)和fun(const char *a)`，这里加了const，const修饰`*a`，也就是说，**不能通过这个指针去改它所指向位置存储的变量**；引用也是同样的道理。而如果const只是修饰int这种类型数据，由于函数参数值传递，无论函数体里面怎么对int参数修改，都影响不到人家外面的int变量，所以加不加const无所谓。

如果有一个函数参数用const修饰，在函数体中就不能改变这个参数。


## 3、volatile

- 提醒编译器它定义的变量**随时都有可能改变**，因此编译后的程序每次需要存储或读取这个变量的时候，告诉**编译器对该变量不做优化**。
- 要求每次直接读值，直接从变量**内存地址**中读取数据，从而可以提供对特殊地址的稳定访问。

```C++
// 会执⾏，不会被优化掉
for(volatile int i=0; i<100000; i++); 
```

**一个参数可以同时是const和volatile的**。比如只读的状态寄存器。它是volatile因为它可能被意想不到地改变。它是const因为程序不应该试图去修改它。

关键：**随时可以改变**。

## 4、static

static 变量的生命周期是从程序开始到结束。

### 静态局部变量

静态局部变量使用static修饰符定义，即使在声明时未赋初值，编译器也会把它初始化为0。且静态局部变量存储于进程的**全局数据区**，即使函数返回，它的值也会保持不变。

其作用域为**局部作用域**，只有在定义它的函数内部才可以使用。

### 静态全局变量

全局变量定义在函数体外部，在全局数据区分配存储空间，且编译器会自动对其初始化。

**普通全局变量**对整个工程可见，其他文件可以使用extern外部声明后直接使用，也就是说其他文件不能再定义一个与其相同名字的变量了（否则编译器会认为它们是同一个变量）

**静态全局变量仅对当前文件可见**，其他文件不可访问，其他文件可以定义与其同名的变量，两者互不影响。

在定义不需要与其他文件共享的全局变量时，加上static关键字能够有效地降低程序模块之间的耦合，避免不同文件同名变量的冲突，且不会误使用。

### 静态函数

函数返回类型前加上static，就是静态函数。静态函数**只能在声明它的文件中可见，其他文件不能引用该函数**。不同的文件可以使用相同名字的静态函数，互不影响。

### 静态数据成员

静态成员函数属于整个类，而不是某一个对象。要在类中声明，类外初始化，且外部初始化不加static关键字，如`<数据类型><类名>::<静态数据成员名>=<值>`。

- 静态数据成员存储在全局数据区，静态数据成员在定义时分配存储空间，所以不能在类声明中定义。
- 类的静态数据成员有两种访问方式：<类对象名>.<静态数据成员名> 或 <类类型名>::<静态数据成员名>
- 
### 静态成员函数

- 静态成员函数属于整个类，而不是某一个对象。
- 静态成员函数没有this指针，它无法访问属于类对象的非静态数据成员，也无法访问非静态成员函数，它**只能**调用其余的静态成员函数、使用静态成员变量。
- 出现在类体外的函数定义不能指定关键字static
- **非**静态成员函数可以**任意**地访问静态成员函数和静态数据成员

## 5、extern

利用关键字extern，可以使用在函数后边定义的全局变量，可以在一个文件中引用另一个文件中定义的变量或者函数。

利用extern关键字先声明一下变量，告诉编译器，这个变量是存在的，可能在别的地方，编译器一定可以找到，所以我在这里可以使用。

**extern关键字只需要指明类型和变量名，不能再重新赋值**，只是告诉编译器这个东西是存在的。初始化需要在原来的地方进行的，如果不进行初始化的话，全局变量会被编译器自动初始化为0。

引用函数也一样，`extern void func();`，可以引用其他文件中的函数，就不需要在include了，include会把被包含的文件中的所有的变量和方法都可以被这个文件使用，不安全。


## 6、override

写在子类继承了的父类的虚函数的后面，编译器看到有override关键字，**会检查父类的这个函数是不是虚函数**，相当于增加了一种保障机制吧。